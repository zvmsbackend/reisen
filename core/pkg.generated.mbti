// Generated using `moon info`, DON'T EDIT IT
package "sennenki/reisen/core"

import {
  "moonbit-community/js-ffi/js",
  "moonbitlang/core/json",
  "sennenki/reisen/assets",
  "sennenki/reisen/gallery",
  "sennenki/reisen/pixi",
  "sennenki/reisen/state",
}

// Values
pub fn anim_blur(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_brightness(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_blue(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_green(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_red(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_contrast(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_gamma(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_opacity(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_position(Int, Position?, Position, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_rotation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_saturation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_scale(Int, Double?, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn effect_spec(@pixi.Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, blocking? : Bool, easing? : Easing) -> EffectSpec

pub fn label(name? : String) -> Label

pub fn option(String, Label, id? : String) -> ChoiceOption

pub fn place_center(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_custom(Double, Double, layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_left(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_right(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn[T] reisen_parse_sexp_script(String) -> Script[T] raise ScriptBuildError

pub fn[T] reisen_parse_sexp_script_with_parser(String, SexpScriptParser[T]) -> Script[T] raise ScriptBuildError

pub fn[T] reisen_sexp_script_to_builder(String, ScriptBuilder[T]) -> Unit

pub fn[T] script((ScriptBuilder[T]) -> Unit) -> Script[T] raise ScriptBuildError

pub fn[T] script_from_instructions(Array[Instruction[T]]) -> Script[T] raise ScriptBuildError

// Errors
pub suberror ReisenSexpError
pub impl Eq for ReisenSexpError
pub impl Show for ReisenSexpError

pub suberror ScriptBuildError {
  DuplicateLabel(name~ : String)
  MissingJumpTarget(target~ : String)
  MissingChoiceTarget(choice_id~ : String, target~ : String)
}

pub suberror ScriptRuntimeError {
  LabelNotFound(label~ : String)
  ChoiceNotActive
  ChoiceNotFound(id~ : String)
  InvalidInstructionPointer(ip~ : Int)
}

// Types and methods
pub(all) enum AnimProp {
  Opacity
  Position
  Scale
  Rotation
  Blur
  Brightness
  Contrast
  Saturation
  Gamma
  ColorRed
  ColorGreen
  ColorBlue
}
pub impl Eq for AnimProp
pub impl Show for AnimProp
pub impl ToJson for AnimProp
pub impl @json.FromJson for AnimProp

pub(all) struct AnimationSpec {
  prop : AnimProp
  duration_ms : Int
  easing : Easing
  from : Array[Double]?
  to : Array[Double]?
  anchor : Array[Double]?
  blocking : Bool
}
pub impl Eq for AnimationSpec
pub impl Show for AnimationSpec
pub impl ToJson for AnimationSpec
pub impl @json.FromJson for AnimationSpec

pub(all) struct BackgroundState {
  id : String
  scalars : ScalarState
}
pub impl Eq for BackgroundState
pub impl Show for BackgroundState
pub impl ToJson for BackgroundState
pub impl @json.FromJson for BackgroundState

pub struct ChoiceOption {
  id : String
  text : String
  jump : String
}
pub impl Eq for ChoiceOption
pub impl Show for ChoiceOption
pub impl ToJson for ChoiceOption
pub impl @json.FromJson for ChoiceOption

pub(all) struct DialogLogEntry {
  speaker : String
  text : String
}
pub impl Eq for DialogLogEntry
pub impl Show for DialogLogEntry
pub impl ToJson for DialogLogEntry
pub impl @json.FromJson for DialogLogEntry

pub(all) struct DomFigureState {
  placement : FigurePlacement
  interactive : Bool
}
pub impl Eq for DomFigureState
pub impl Show for DomFigureState
pub impl ToJson for DomFigureState
pub impl @json.FromJson for DomFigureState

pub(all) enum Easing {
  Linear
  EaseIn
  EaseOut
  EaseInOut
}
pub impl Eq for Easing
pub impl Show for Easing
pub impl ToJson for Easing
pub impl @json.FromJson for Easing

pub(all) enum EffectPhase {
  Pre
  Post
}
pub impl Eq for EffectPhase
pub impl Show for EffectPhase
pub impl ToJson for EffectPhase
pub impl @json.FromJson for EffectPhase

pub(all) struct EffectSpec {
  id : String
  params : Array[(String, Double)]
  phase : EffectPhase
  duration_ms : Int?
  easing : Easing
  blocking : Bool
}
pub impl Eq for EffectSpec
pub impl Show for EffectSpec
pub impl ToJson for EffectSpec
pub impl @json.FromJson for EffectSpec

pub(all) struct FigurePlacement {
  pos : Position
  layer : Int
  scalars : ScalarState
}
pub impl Eq for FigurePlacement
pub impl Show for FigurePlacement
pub impl ToJson for FigurePlacement
pub impl @json.FromJson for FigurePlacement

pub(all) enum Instruction[T] {
  Label(String)
  Jump(String)
  JumpIf(String, (@state.GameState[T]) -> Bool)
  JumpBy((@state.GameState[T]) -> Label)
  Wait(Int)
  WaitForClick(Bool)
  WaitCustomEvent(String, (@state.GameState[T], String) -> Bool)
  WaitCustomEventJump(String, (@state.GameState[T], String) -> Label)
  Say(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?, proceed_on_done~ : Bool)
  Intro(String)
  ShowTextBox
  HideTextBox
  ShowAvatar(String)
  HideAvatar
  PlayVideo(String, Bool)
  Choice(Array[ChoiceOption])
  InputText(String, String)
  RunCode((@state.GameState[T]) -> Unit)
  ShowBackground(String)
  ShowBackgroundState(BackgroundState)
  ShowFigure(String, FigurePlacement)
  HideFigure(String)
  ShowDomFigure(String, FigurePlacement, Bool)
  HideDomFigure(String)
  SetDomFigureInteractive(String, Bool)
  PlayMusic(String, Bool)
  StopMusic
  PlaySfx(String, Bool)
  UnlockCg(String)
  AnimatePixi(String, AnimationSpec)
  AnimateDom(String, AnimationSpec)
  ApplyEffect(String, EffectSpec)
  PlayLive2dMotion(String, String, Int?)
  SetLive2dExpression(String, String?)
}

pub struct Label(String)
#deprecated
pub fn Label::inner(Self) -> String

pub(all) enum Position {
  Left
  Center
  Right
  Custom(Double, Double)
}
pub impl Eq for Position
pub impl Show for Position
pub impl ToJson for Position
pub impl @json.FromJson for Position

pub struct Runtime[T] {
  script : Script[T]
  state : @state.GameState[T]
  mut ip : Int
  mut pending_choices : Array[ChoiceOption]
  mut pending_choice_ip : Int?
  mut pending_text_input : (String, String)?
  mut wait_ms : Int
  mut wait_for_click : Bool
  mut wait_for_click_can_skip : Bool
  mut wait_custom_name : String?
  mut wait_video : Bool
  mut last_say_proceed_on_done : Bool
  mut ended : Bool
  flow_trace : Array[ScriptFlowTrace]
}
pub fn[T] Runtime::can_auto_skip_wait_click(Self[T]) -> Bool
pub fn[T] Runtime::can_skip_wait(Self[T]) -> Bool
pub fn[T] Runtime::choose(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::complete_video_wait(Self[T], Bool) -> RuntimeEvent
pub fn[T] Runtime::flow_trace(Self[T]) -> Array[ScriptFlowTrace]
pub fn[T] Runtime::force_custom_jump(Self[T], String, String) -> Unit raise ScriptRuntimeError
pub fn[T : @json.FromJson] Runtime::from_json_string(Script[T], String) -> Self[T] raise
pub fn[T] Runtime::from_save(Script[T], RuntimeSave[T]) -> Self[T] raise ScriptRuntimeError
pub fn[T] Runtime::ip(Self[T]) -> Int
pub fn[T] Runtime::is_waiting(Self[T]) -> Bool
pub fn[T] Runtime::is_waiting_video(Self[T]) -> Bool
pub fn[T] Runtime::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] Runtime::last_say_proceed_on_done(Self[T]) -> Bool
pub fn[T] Runtime::new(Script[T], @state.GameState[T]) -> Self[T]
pub fn[T] Runtime::save(Self[T]) -> RuntimeSave[T]
pub fn[T : ToJson] Runtime::save_json(Self[T]) -> String
pub fn[T] Runtime::skip_wait(Self[T]) -> Unit
pub fn[T] Runtime::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] Runtime::submit_text_input(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError

pub(all) enum RuntimeEvent {
  Noop
  Said(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?)
  IntroShown(String)
  TextBoxShown
  TextBoxHidden
  AvatarShown(String)
  AvatarHidden
  VideoStarted(String, Bool)
  VideoEnded(Bool)
  ChoicePrompt(Array[ChoiceOption])
  TextInputPrompt(String, String)
  BackgroundShown(String)
  BackgroundShownState(BackgroundState)
  FigureShown(String, FigurePlacement)
  FigureHidden(String)
  DomFigureShown(String, FigurePlacement, Bool)
  DomFigureHidden(String)
  DomFigureInteractiveSet(String, Bool)
  MusicPlayed(String, Bool)
  MusicStopped
  SfxPlayed(String, Bool)
  SfxStopped
  CgUnlocked(String)
  AnimatedPixi(String, AnimationSpec)
  AnimatedDom(String, AnimationSpec)
  EffectApplied(String, EffectSpec)
  Live2dMotionPlayed(String, String, Int?)
  Live2dExpressionSet(String, String?)
  WaitStarted(Int)
  WaitForClickStarted
  WaitCustomEventStarted(String)
  Custom(String, String)
  ScriptEnded
}
pub impl Eq for RuntimeEvent
pub impl Show for RuntimeEvent

pub struct RuntimeSave[T] {
  state : @state.GameState[T]
  ip : Int
  pending_choices : Array[ChoiceOption]
  pending_choice_ip : Int?
  pending_text_input : (String, String)?
  wait_ms : Int
  wait_for_click : Bool
  wait_for_click_can_skip : Bool
  wait_custom_name : String?
  wait_video : Bool
  last_say_proceed_on_done : Bool
  ended : Bool
  flow_trace : Array[ScriptFlowTrace]
}
pub impl[T : ToJson] ToJson for RuntimeSave[T]
pub impl[T : @json.FromJson] @json.FromJson for RuntimeSave[T]

pub(all) struct ScalarState {
  opacity : Double
  scale : Double
  rotation : Double
  blur : Double
  brightness : Double
  contrast : Double
  saturation : Double
  gamma : Double
  color_r : Double
  color_g : Double
  color_b : Double
}
pub impl Default for ScalarState
pub impl Eq for ScalarState
pub impl Show for ScalarState
pub impl ToJson for ScalarState
pub impl @json.FromJson for ScalarState

pub struct Script[T] {
  instructions : Array[Instruction[T]]
  labels : Map[String, Int]
}

type ScriptBuilder[T]
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate(Self[T], A, AnimationSpec) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_blur(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_brightness(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_blue(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_green(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_red(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_contrast(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_gamma(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_opacity(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_position(Self[T], A, Int, from? : Position, Position, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_rotation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_saturation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_scale(Self[T], A, Int, from? : Double, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::apply(Self[T], (Self[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::branch(Self[T], Label, Label, (@state.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::build(Self[T]) -> Script[T] raise ScriptBuildError
pub fn[T] ScriptBuilder::choice(Self[T], Array[ChoiceOption]) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect(Self[T], A, EffectSpec) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect_with(Self[T], A, @pixi.Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::hide_avatar(Self[T]) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::hide_figure(Self[T], F) -> Unit
pub fn[T] ScriptBuilder::hide_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::input_text(Self[T], String, String) -> Unit
pub fn[T] ScriptBuilder::intro(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::jump(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::jump_by(Self[T], (@state.GameState[T]) -> Label) -> Unit
pub fn[T] ScriptBuilder::jump_if(Self[T], Label, (@state.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::label(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::load_sexp(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::menu(Self[T], String, String, Array[ChoiceOption]) -> Unit
pub fn[T] ScriptBuilder::narrate(Self[T], String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::new() -> Self[T]
pub fn[T] ScriptBuilder::play_live2d_motion(Self[T], @assets.Live2dFigure, String, index? : Int) -> Unit
pub fn[T] ScriptBuilder::play_music(Self[T], @assets.Music, Bool) -> Unit
pub fn[T] ScriptBuilder::play_sfx(Self[T], @assets.Sfx, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::play_video(Self[T], String, can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::run_code(Self[T], (@state.GameState[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::say(Self[T], String, String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::say_many(Self[T], String, Array[String], typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::scene(Self[T], @assets.Background, scalars? : ScalarState) -> Unit
pub fn[T] ScriptBuilder::set_figure_interactive(Self[T], @assets.DomFigure, Bool) -> Unit
pub fn[T] ScriptBuilder::set_live2d_expression(Self[T], @assets.Live2dFigure, id? : String) -> Unit
pub fn[T] ScriptBuilder::show_avatar(Self[T], String) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure(Self[T], F, FigurePlacement, interactive? : Bool) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure_at(Self[T], F, Position, layer? : Int, scalars? : ScalarState, interactive? : Bool) -> Unit
pub fn[T] ScriptBuilder::show_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::stop_music(Self[T]) -> Unit
pub fn[T] ScriptBuilder::unlock_cg(Self[T], @gallery.GalleryImage) -> Unit
pub fn[T] ScriptBuilder::wait(Self[T], Int) -> Unit
pub fn[T] ScriptBuilder::wait_click(Self[T], can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event(Self[T], String, (@state.GameState[T], String) -> Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event_jump(Self[T], String, (@state.GameState[T], String) -> Label) -> Unit

pub enum ScriptFlowTrace {
  ChoiceResolved(ip~ : Int, choice_id~ : String)
  JumpIfResolved(ip~ : Int, target~ : String, taken~ : Bool)
  CustomJumpResolved(ip~ : Int, name~ : String, target~ : String)
}
pub impl Eq for ScriptFlowTrace
pub impl Show for ScriptFlowTrace
pub impl ToJson for ScriptFlowTrace
pub impl @json.FromJson for ScriptFlowTrace

pub struct SexpScriptParser[T] {
  host_functions : Map[String, (@state.GameState[T], ArrayView[@js.Value]) -> @js.Value]
}
pub fn[T] SexpScriptParser::new() -> Self[T]
pub fn[T] SexpScriptParser::register_function(Self[T], String, (@state.GameState[T], ArrayView[@js.Value]) -> @js.Value) -> Unit

pub(all) struct UiSnapshot {
  dialog : (String, String, Bool, Bool)?
  dialog_seq : Int
  dialog_history : Array[DialogLogEntry]
  choices : Array[ChoiceOption]
  text_input : (String, String)?
  intro_text : String?
  video : (String, Bool)?
  text_box_visible : Bool
  avatar_id : String?
  dom_figures : Map[String, DomFigureState]
  dom_animations : Array[(String, AnimationSpec)]
}
pub impl Default for UiSnapshot
pub impl Eq for UiSnapshot
pub impl Show for UiSnapshot

// Type aliases
pub type EventHook = (RuntimeEvent) -> Unit

pub type PayloadJumpSelector[T] = (@state.GameState[T], String) -> Label

pub type PayloadPredicate[T] = (@state.GameState[T], String) -> Bool

pub type ScriptHook[T] = (@state.GameState[T]) -> Unit

pub type ScriptJumpSelector[T] = (@state.GameState[T]) -> Label

pub type ScriptPredicate[T] = (@state.GameState[T]) -> Bool

pub type SexpHostFunction[T] = (@state.GameState[T], ArrayView[@js.Value]) -> @js.Value

// Traits

