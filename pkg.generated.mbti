// Generated using `moon info`, DON'T EDIT IT
package "sennenki/reisen"

import {
  "moonbit-community/js-ffi/js",
  "moonbitlang/core/json",
}

// Values
pub fn anim_blur(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_brightness(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_blue(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_green(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_red(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_contrast(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_gamma(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_opacity(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_position(Int, Position?, Position, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_rotation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_saturation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_scale(Int, Double?, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn audio_dom_has_active_sfx() -> Bool

pub fn[T : @json.FromJson] director_from_save_json(Script[T], String) -> Director[T] raise

pub fn dom_figure(String) -> DomFigure

pub fn effect_spec(Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, blocking? : Bool, easing? : Easing) -> EffectSpec

pub fn gallery_image_by_id(String) -> GalleryImage?

pub fn gallery_is_image_unlocked(GalleryImage) -> Bool

pub fn gallery_is_image_unlocked_in(String, GalleryImage) -> Bool

pub fn gallery_lock_image(GalleryImage) -> Unit

pub fn gallery_lock_image_in(String, GalleryImage) -> Unit

pub fn gallery_register_image(GalleryImage) -> Unit

pub fn gallery_registered_images() -> Array[GalleryImage]

pub fn gallery_replayable_images() -> Array[GalleryImage]

pub fn gallery_replayable_images_in(String) -> Array[GalleryImage]

pub fn gallery_unlock_image(GalleryImage) -> Unit

pub fn gallery_unlock_image_in(String, GalleryImage) -> Unit

pub fn gallery_unlocked_images() -> Array[GalleryImage]

pub fn gallery_unlocked_images_in(String) -> Array[GalleryImage]

pub fn game_settings_default() -> GameSettings

pub fn[T : @json.FromJson] game_state_from_json_string(String) -> GameState[T] raise

pub fn gensym(prefix? : String) -> String

pub fn get_canvas_by_id(String) -> PixiCanvas?

pub fn js_float32_array(Array[Double]) -> @js.Value

pub fn js_uint16_array(Array[Int]) -> @js.Value

pub fn js_uint8_array(Array[Int]) -> @js.Value

pub fn label(name? : String) -> Label

pub async fn load_bytes(String) -> Bytes

pub async fn load_image(String) -> Image

pub async fn load_text(String) -> String

pub async fn load_video(String) -> Video

pub fn[T] make_pixi_render_sync_hook_from_canvas(String, AssetStore) -> ((Director[T]) -> Unit)?

pub fn[T] make_pixi_render_sync_hook_from_canvas_element(PixiCanvas, AssetStore) -> (Director[T]) -> Unit

pub fn[T] make_pixi_render_sync_hook_from_canvas_element_with_config(PixiCanvas, AssetStore, PixiPresenterConfig) -> (Director[T]) -> Unit

pub fn[T] make_pixi_render_sync_hook_from_canvas_with_config(String, AssetStore, PixiPresenterConfig) -> ((Director[T]) -> Unit)?

pub fn option(String, Label, id? : String) -> ChoiceOption

pub fn persistent_delete(String) -> Unit

pub fn persistent_delete_in(String, String) -> Unit

pub fn persistent_get_flag(String, default? : Bool) -> Bool

pub fn persistent_get_flag_in(String, String, default? : Bool) -> Bool

pub fn persistent_get_int(String, default? : Int) -> Int

pub fn persistent_get_int_in(String, String, default? : Int) -> Int

pub fn persistent_get_text(String, default? : String) -> String

pub fn persistent_get_text_in(String, String, default? : String) -> String

pub fn persistent_keys() -> Array[String]

pub fn persistent_keys_in(String) -> Array[String]

pub fn persistent_set_flag(String, Bool) -> Unit

pub fn persistent_set_flag_in(String, String, Bool) -> Unit

pub fn persistent_set_int(String, Int) -> Unit

pub fn persistent_set_int_in(String, String, Int) -> Unit

pub fn persistent_set_text(String, String) -> Unit

pub fn persistent_set_text_in(String, String, String) -> Unit

pub async fn pixi_assets_load_texture(String) -> PixiTexture raise PixiBindingError

pub async fn pixi_load_live2d_model(String) -> PixiLive2dModel raise PixiBindingError

pub fn pixi_new_application() -> PixiApplication

pub fn pixi_new_blur_filter() -> PixiBlurFilter

pub fn pixi_new_color_matrix_filter() -> PixiColorMatrixFilter

pub fn pixi_new_container() -> PixiContainer

pub fn pixi_new_filter(String, String) -> PixiFilter

pub fn pixi_new_sprite(PixiTexture) -> PixiSprite

pub fn pixi_presenter_default_config() -> PixiPresenterConfig

pub fn pixi_texture_from(@js.Value) -> PixiTexture

pub fn place_center(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_custom(Double, Double, layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_left(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_right(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn register_pixi_effect((PixiSprite, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn register_pixi_effect_shared((PixiEffectTarget, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn[T] reisen_parse_text_script(String) -> Script[T] raise ScriptBuildError

pub async fn[T : @json.FromJson + ToJson] run_browser_app_loop(AppController[T]) -> Unit

pub async fn[T] run_browser_loop(GameRunner[T]) -> Unit

pub fn[T : ToJson] save_director_to_slot(Director[T], String, save_namespace? : String) -> Unit

pub fn[T : ToJson] save_runner_to_slot(GameRunner[T], String, save_namespace? : String) -> Unit

pub fn[T : ToJson] save_runner_to_slot_with_meta(GameRunner[T], String, title? : String, preview? : String, save_namespace? : String) -> Unit

pub fn save_slot_delete(String) -> Unit

pub fn save_slot_delete_in(String, String) -> Unit

pub fn save_slot_entries() -> Array[SaveSlotEntry]

pub fn save_slot_entries_in(String) -> Array[SaveSlotEntry]

pub fn save_slot_list() -> Array[String]

pub fn save_slot_list_in(String) -> Array[String]

pub fn save_slot_meta(String, String, updated_at_ms? : Double) -> SaveSlotMeta

pub fn save_slot_read(String) -> String?

pub fn save_slot_read_in(String, String) -> String?

pub fn save_slot_read_meta(String) -> SaveSlotMeta?

pub fn save_slot_read_meta_in(String, String) -> SaveSlotMeta?

pub fn save_slot_write(String, String) -> Unit

pub fn save_slot_write_in(String, String, String) -> Unit

pub fn save_slot_write_meta(String, SaveSlotMeta) -> Unit

pub fn save_slot_write_meta_in(String, String, SaveSlotMeta) -> Unit

pub fn[T] script((ScriptBuilder[T]) -> Unit) -> Script[T] raise ScriptBuildError

pub fn[T] script_from_instructions(Array[Instruction[T]]) -> Script[T] raise ScriptBuildError

pub fn settings_read() -> GameSettings?

pub fn settings_read_in(String) -> GameSettings?

pub fn settings_write(GameSettings) -> Unit

pub fn settings_write_in(String, GameSettings) -> Unit

pub fn[T] start_game(Script[T], GameState[T], String, render_sync? : (Director[T]) -> Unit, event_hook? : (RuntimeEvent) -> Unit, settings? : GameSettings) -> GameRunner[T]

pub fn[T : @json.FromJson] start_game_from_save(Script[T], String, String, render_sync? : (Director[T]) -> Unit, event_hook? : (RuntimeEvent) -> Unit, settings? : GameSettings) -> GameRunner[T] raise

pub fn[T : @json.FromJson] start_game_from_slot(Script[T], String, String, render_sync? : (Director[T]) -> Unit, event_hook? : (RuntimeEvent) -> Unit, save_namespace? : String, settings? : GameSettings) -> GameRunner[T] raise

pub fn[T] start_game_webgl(Script[T], GameState[T], String, WebGL, AssetStore, presenter_config? : PixiPresenterConfig, settings? : GameSettings) -> GameRunner[T] raise

pub fn[T] start_game_webgl_with_audio(Script[T], GameState[T], String, WebGL, AssetStore, AudioDom, presenter_config? : PixiPresenterConfig, settings? : GameSettings) -> GameRunner[T] raise

pub fn[T] validate_script_assets(Script[T], AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_audio_assets(Script[T], AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_image_assets(Script[T], AssetStore) -> Unit raise AppBootstrapError

pub fn window_inner_height() -> Double

pub fn window_inner_width() -> Double

// Errors
pub suberror AppBootstrapError {
  MissingImageAsset(id~ : String)
  MissingAudioAsset(id~ : String)
  MissingSaveSlot(slot~ : String)
}

pub suberror PixiBindingError {
  ResourceLoadFailed(message~ : String)
}

pub suberror ReisenTextError {
}
pub impl Eq for ReisenTextError
pub impl Show for ReisenTextError

pub(all) suberror ScriptBuildError {
  DuplicateLabel(name~ : String)
  MissingJumpTarget(target~ : String)
  MissingChoiceTarget(choice_id~ : String, target~ : String)
  EffectUnsupportedOnDomTarget(target~ : String)
  SetInteractiveUnsupportedOnWebglTarget(target~ : String)
}

pub suberror ScriptRuntimeError {
  LabelNotFound(label~ : String)
  ChoiceNotActive
  ChoiceNotFound(id~ : String)
  InvalidInstructionPointer(ip~ : Int)
}

// Types and methods
pub enum AnimProp {
  Opacity
  Position
  Scale
  Rotation
  Blur
  Brightness
  Contrast
  Saturation
  Gamma
  ColorRed
  ColorGreen
  ColorBlue
}
pub impl Eq for AnimProp
pub impl Show for AnimProp
pub impl ToJson for AnimProp
pub impl @json.FromJson for AnimProp

pub struct AnimationSpec {
  prop : AnimProp
  duration_ms : Int
  easing : Easing
  from : Array[Double]?
  to : Array[Double]?
  anchor : Array[Double]?
  blocking : Bool
}
pub impl Eq for AnimationSpec
pub impl Show for AnimationSpec
pub impl ToJson for AnimationSpec
pub impl @json.FromJson for AnimationSpec

type AppController[T]
pub fn[T] AppController::new(async () -> Script[T], () -> GameState[T], String, save_namespace? : String, autosave_slot? : String, autosave_title? : String, menu_background? : String, settings_background? : String, gallery_background? : String, menu_music? : Music, menu_music_loop? : Bool, start_logo_urls? : Array[String], start_logo_duration_ms? : Int, render_sync? : (Director[T]) -> Unit, event_hook? : (RuntimeEvent) -> Unit, gallery_replay_state_factories? : ReplayStateFactories[T]) -> Self[T]
pub fn[T] AppController::phase(Self[T]) -> AppPhase
pub fn[T] AppController::submit_custom_event(Self[T], String, String) -> Bool
pub async fn[T : @json.FromJson + ToJson] AppController::tick(Self[T], elapsed_ms? : Int) -> Bool

pub enum AppPhase {
  StartGate
  StartLogo
  StartMenu
  Gallery
  Settings
  InGame
}
pub impl Eq for AppPhase
pub impl Show for AppPhase

type AssetStore
pub fn AssetStore::get_bytes(Self, String) -> Bytes?
pub fn AssetStore::get_image(Self, String) -> Image?
pub fn AssetStore::get_live2d_model(Self, String) -> PixiLive2dModel?
pub fn AssetStore::get_text(Self, String) -> String?
pub fn AssetStore::get_video(Self, String) -> Video?
pub fn AssetStore::new() -> Self
pub fn AssetStore::put_bytes(Self, String, Bytes) -> Unit
pub fn AssetStore::put_image(Self, String, Image) -> Unit
pub fn AssetStore::put_live2d_model(Self, String, PixiLive2dModel) -> Unit
pub fn AssetStore::put_text(Self, String, String) -> Unit
pub fn AssetStore::put_video(Self, String, Video) -> Unit
pub async fn AssetStore::register_background(Self, String, id? : String) -> Background
pub async fn AssetStore::register_background_video(Self, String, id? : String) -> Background
pub async fn AssetStore::register_figure(Self, String, id? : String) -> PixiFigure
pub async fn AssetStore::register_live2d_figure(Self, String, id? : String) -> Live2dFigure raise PixiBindingError

type AudioCommand
pub impl Eq for AudioCommand
pub impl Show for AudioCommand

type AudioDom
pub fn AudioDom::apply_settings(Self, GameSettings) -> Unit
pub fn AudioDom::as_event_hook(Self) -> (RuntimeEvent) -> Unit
pub fn AudioDom::handle_event(Self, RuntimeEvent) -> Unit
pub fn AudioDom::new() -> Self
pub fn AudioDom::register_music(Self, String, id? : String) -> Music
pub fn AudioDom::register_sfx(Self, String, id? : String) -> Sfx
pub fn AudioDom::set_bgm_gain(Self, Double) -> Unit
pub fn AudioDom::set_sfx_gain(Self, Double) -> Unit

type Background
pub fn Background::as_gallery_image(Self, String, thumbnail? : Self, replay_label? : Label, replay_state_factory_key? : ReplayStateFactoryKey, id? : String) -> GalleryImage
pub impl AnimationTarget for Background
pub impl PixiTarget for Background

pub struct BackgroundState {
  id : String
  scalars : ScalarState
}
pub impl Eq for BackgroundState
pub impl Show for BackgroundState
pub impl ToJson for BackgroundState
pub impl @json.FromJson for BackgroundState

type Canvas
pub fn Canvas::get_webgl2_context(Self) -> WebGL?
pub fn Canvas::get_webgl_context(Self) -> WebGL?

type ChoiceOption
pub impl Eq for ChoiceOption
pub impl Show for ChoiceOption
pub impl ToJson for ChoiceOption
pub impl @json.FromJson for ChoiceOption

type DialogLine
pub impl Eq for DialogLine
pub impl Show for DialogLine
pub impl ToJson for DialogLine
pub impl @json.FromJson for DialogLine

type Director[T]
pub fn[T] Director::animations(Self[T]) -> Array[(String, AnimationSpec)]
pub fn[T] Director::avatar_id(Self[T]) -> String?
pub fn[T] Director::background(Self[T]) -> String?
pub fn[T] Director::background_state(Self[T]) -> BackgroundState?
pub fn[T] Director::choices(Self[T]) -> Array[ChoiceOption]
pub fn[T] Director::choose(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::clear_dialog(Self[T]) -> Unit
pub fn[T] Director::clear_render(Self[T]) -> Unit
pub fn[T] Director::complete_video_wait(Self[T], Bool) -> RuntimeEvent
pub fn[T] Director::dialog(Self[T]) -> DialogLine?
pub fn[T] Director::dom_animations(Self[T]) -> Array[(String, AnimationSpec)]
pub fn[T] Director::dom_figures(Self[T]) -> Map[String, DomFigureState]
pub fn[T] Director::effects(Self[T], String) -> Array[EffectSpec]
pub fn[T] Director::figure(Self[T], String) -> FigurePlacement?
pub fn[T] Director::figures(Self[T]) -> Map[String, FigurePlacement]
pub fn[T] Director::from_save(Script[T], DirectorSave[T]) -> Self[T] raise ScriptRuntimeError
pub fn[T] Director::intro_text(Self[T]) -> String?
pub fn[T] Director::is_waiting(Self[T]) -> Bool
pub fn[T] Director::is_waiting_video(Self[T]) -> Bool
pub fn[T] Director::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] Director::last_sfx(Self[T]) -> String?
pub fn[T] Director::live2d_expressions(Self[T]) -> Array[(String, String?)]
pub fn[T] Director::live2d_motions(Self[T]) -> Array[(String, String, Int?)]
pub fn[T] Director::music(Self[T]) -> (String, Bool)?
pub fn[T] Director::new(Runtime[T]) -> Self[T]
pub fn[T] Director::render_epoch(Self[T]) -> String
pub fn[T : ToJson] Director::save_json(Self[T]) -> String
pub fn[T] Director::set_background_state(Self[T], BackgroundState) -> Unit
pub fn[T] Director::skip_wait(Self[T]) -> Unit
pub fn[T] Director::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] Director::submit_text_input(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::take_interrupted_sfx(Self[T]) -> String?
pub fn[T] Director::text_box_visible(Self[T]) -> Bool
pub fn[T] Director::text_input(Self[T]) -> (String, String)?
pub fn[T] Director::video(Self[T]) -> (String, Bool)?

pub struct DirectorSave[T] {
  runtime : RuntimeSave[T]
  render : RenderState
  dialog : DialogLine?
  intro_text : String?
  video : (String, Bool)?
  text_box_visible : Bool
  avatar_id : String?
}
pub impl[T : ToJson] ToJson for DirectorSave[T]
pub impl[T : @json.FromJson] @json.FromJson for DirectorSave[T]

type DomFigure
pub impl AnimationTarget for DomFigure
pub impl Figure for DomFigure

pub struct DomFigureState {
  placement : FigurePlacement
  interactive : Bool
}
pub impl Eq for DomFigureState
pub impl Show for DomFigureState
pub impl ToJson for DomFigureState
pub impl @json.FromJson for DomFigureState

pub(all) enum Easing {
  Linear
  EaseIn
  EaseOut
  EaseInOut
}
pub impl Eq for Easing
pub impl Show for Easing
pub impl ToJson for Easing
pub impl @json.FromJson for Easing

type Effect

pub(all) enum EffectPhase {
  Pre
  Post
}
pub impl Eq for EffectPhase
pub impl Show for EffectPhase
pub impl ToJson for EffectPhase
pub impl @json.FromJson for EffectPhase

pub struct EffectSpec {
  id : String
  params : Array[(String, Double)]
  phase : EffectPhase
  duration_ms : Int?
  easing : Easing
  blocking : Bool
}
pub impl Eq for EffectSpec
pub impl Show for EffectSpec
pub impl ToJson for EffectSpec
pub impl @json.FromJson for EffectSpec

pub struct FigurePlacement {
  pos : Position
  layer : Int
  scalars : ScalarState
}
pub impl Eq for FigurePlacement
pub impl Show for FigurePlacement
pub impl ToJson for FigurePlacement
pub impl @json.FromJson for FigurePlacement

type GalleryImage
pub fn GalleryImage::id(Self) -> String
pub fn GalleryImage::new(String, String, title? : String, thumbnail_url? : String, replay_label? : String, replay_state_factory_key? : ReplayStateFactoryKey) -> Self
pub impl Eq for GalleryImage
pub impl Show for GalleryImage
pub impl ToJson for GalleryImage
pub impl @json.FromJson for GalleryImage

type GalleryTileView
pub impl Eq for GalleryTileView
pub impl Show for GalleryTileView
pub impl ToJson for GalleryTileView
pub impl @json.FromJson for GalleryTileView

type GameRunner[T]
pub fn[T] GameRunner::apply_runtime_event(Self[T], RuntimeEvent) -> Unit
pub fn[T] GameRunner::apply_settings(Self[T], GameSettings) -> Unit
pub fn[T] GameRunner::clear_presentation(Self[T]) -> Unit
pub fn[T] GameRunner::clear_ui(Self[T]) -> Unit
pub fn[T] GameRunner::complete_typewriter(Self[T]) -> Unit
pub fn[T] GameRunner::director(Self[T]) -> Director[T]
pub fn[T] GameRunner::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] GameRunner::new(Director[T], UiDom) -> Self[T]
pub fn[T] GameRunner::new_with_hooks(Director[T], UiDom, (Director[T]) -> Unit, (RuntimeEvent) -> Unit) -> Self[T]
pub fn[T] GameRunner::new_with_render_sync(Director[T], UiDom, (Director[T]) -> Unit) -> Self[T]
pub fn[T] GameRunner::simulate_click(Self[T]) -> Unit
pub fn[T] GameRunner::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] GameRunner::submit_choice(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] GameRunner::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] GameRunner::sync_ui(Self[T]) -> Unit
pub fn[T] GameRunner::take_game_action(Self[T]) -> String?
pub fn[T] GameRunner::take_pending_action(Self[T]) -> String?
pub fn[T] GameRunner::tick(Self[T], elapsed_ms? : Int) -> Bool
pub fn[T] GameRunner::toggle_auto_mode(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_skip_mode(Self[T]) -> Unit

pub(all) struct GameSettings {
  text_speed : Int
  bgm_volume : Double
  sfx_volume : Double
}
pub impl Eq for GameSettings
pub impl Show for GameSettings
pub impl ToJson for GameSettings
pub impl @json.FromJson for GameSettings

type GameState[T]
pub fn[T] GameState::flag(Self[T], String) -> Bool
pub fn[T] GameState::get_user_data(Self[T]) -> T
pub fn[T] GameState::int_var(Self[T], String, default_value? : Int) -> Int
pub fn[T] GameState::interpolate(Self[T], String) -> String
pub fn[T] GameState::new(T) -> Self[T]
pub fn[T] GameState::set_flag(Self[T], String, Bool) -> Unit
pub fn[T] GameState::set_int_var(Self[T], String, Int) -> Unit
pub fn[T] GameState::set_text_var(Self[T], String, String) -> Unit
pub fn[T] GameState::set_user_data(Self[T], T) -> Unit
pub fn[T] GameState::text_var(Self[T], String, default_value? : String) -> String
pub fn[T : ToJson] GameState::to_json_string(Self[T]) -> String
pub impl[T : Eq] Eq for GameState[T]
pub impl[T : Show] Show for GameState[T]
pub impl[T : ToJson] ToJson for GameState[T]
pub impl[T : @json.FromJson] @json.FromJson for GameState[T]

type Image
pub impl @js.Cast for Image

pub enum Instruction[T] {
  Label(String)
  Jump(String)
  JumpIf(String, (GameState[T]) -> Bool)
  Wait(Int)
  WaitForClick
  WaitCustomEvent(String, (GameState[T], String) -> Bool)
  WaitCustomEventJump(String, (GameState[T], String) -> Label)
  Say(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?, proceed_on_done~ : Bool)
  Intro(String)
  ShowTextBox
  HideTextBox
  ShowAvatar(String)
  HideAvatar
  PlayVideo(String, Bool)
  Choice(Array[ChoiceOption])
  InputText(String, String)
  RunCode((GameState[T]) -> Unit)
  ShowBackground(String)
  ShowBackgroundState(BackgroundState)
  ShowFigure(String, FigurePlacement)
  HideFigure(String)
  ShowDomFigure(String, FigurePlacement, Bool)
  HideDomFigure(String)
  SetDomFigureInteractive(String, Bool)
  PlayMusic(String, Bool)
  StopMusic
  PlaySfx(String, Bool)
  UnlockCg(String)
  AnimateWebgl(String, AnimationSpec)
  AnimateDom(String, AnimationSpec)
  ApplyEffect(String, EffectSpec)
  PlayLive2dMotion(String, String, Int?)
  SetLive2dExpression(String, String?)
}

type Label

type Live2dFigure
pub impl AnimationTarget for Live2dFigure
pub impl Figure for Live2dFigure
pub impl PixiTarget for Live2dFigure

type Music

type PixiApplication
pub async fn PixiApplication::init_with_canvas(Self, @js.Value, Int, Int, antialias? : Bool, background_alpha? : Double, resolution? : Double, auto_density? : Bool) -> Unit

type PixiBlurFilter

type PixiCanvas

type PixiColorMatrixFilter

type PixiContainer

pub enum PixiEffectTarget {
  Sprite(PixiSprite)
  Live2d(PixiLive2dModel)
}

type PixiFigure
pub impl AnimationTarget for PixiFigure
pub impl Figure for PixiFigure
pub impl PixiTarget for PixiFigure

type PixiFilter

type PixiLive2dModel
pub fn PixiLive2dModel::destroy(Self) -> Unit
pub async fn PixiLive2dModel::expression(Self, id? : String) -> Bool
pub fn PixiLive2dModel::focus(Self, Double, Double, instant? : Bool) -> Unit
pub fn PixiLive2dModel::height(Self) -> Double
pub async fn PixiLive2dModel::motion(Self, String, index? : Int) -> Bool
pub fn PixiLive2dModel::set_alpha(Self, Double) -> Unit
pub fn PixiLive2dModel::set_anchor(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_expression(Self, @js.Optional[String]) -> Unit
pub fn PixiLive2dModel::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiLive2dModel::set_interactive(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_position(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_rotation(Self, Double) -> Unit
pub fn PixiLive2dModel::set_scale(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_size(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_visible(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_z_index(Self, Int) -> Unit
pub fn PixiLive2dModel::start_motion(Self, String, @js.Optional[Int]) -> Unit
pub fn PixiLive2dModel::width(Self) -> Double

pub struct PixiPresenterConfig {
  antialias : Bool
  background_alpha : Double
  resolution : Double
  auto_density : Bool
  position_entry_offset_ratio : Double
  scale_entry_from : Double
}
pub impl Eq for PixiPresenterConfig
pub impl Show for PixiPresenterConfig

type PixiSprite
pub fn PixiSprite::set_alpha(Self, Double) -> Unit
pub fn PixiSprite::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiSprite::set_position(Self, Double, Double) -> Unit
pub fn PixiSprite::set_rotation(Self, Double) -> Unit
pub fn PixiSprite::set_scale(Self, Double, Double) -> Unit
pub fn PixiSprite::set_tint(Self, Int) -> Unit

type PixiTexture

pub(all) enum Position {
  Left
  Center
  Right
  Custom(Double, Double)
}
pub impl Eq for Position
pub impl Show for Position
pub impl ToJson for Position
pub impl @json.FromJson for Position

pub struct RenderState {
  mut background : BackgroundState?
  figures : Map[String, FigurePlacement]
  dom_figures : Map[String, DomFigureState]
  mut music : (String, Bool)?
  mut last_sfx : String?
  mut last_sfx_interrupted : Bool
  webgl_animations : Array[(String, AnimationSpec)]
  dom_animations : Array[(String, AnimationSpec)]
  effects : Map[String, Array[EffectSpec]]
  live2d_motions : Array[(String, String, Int?)]
  live2d_expressions : Array[(String, String?)]
  render_epoch : String
}
pub impl ToJson for RenderState
pub impl @json.FromJson for RenderState

type ReplayStateFactories[T]
pub fn[T] ReplayStateFactories::get(Self[T], ReplayStateFactoryKey) -> (() -> GameState[T])?
pub fn[T] ReplayStateFactories::new() -> Self[T]
pub fn[T] ReplayStateFactories::register(Self[T], () -> GameState[T], key? : String) -> ReplayStateFactoryKey

type ReplayStateFactoryKey
pub impl Eq for ReplayStateFactoryKey
pub impl Show for ReplayStateFactoryKey
pub impl ToJson for ReplayStateFactoryKey
pub impl @json.FromJson for ReplayStateFactoryKey

pub struct Runtime[T] {
  script : Script[T]
  state : GameState[T]
  mut ip : Int
  mut pending_choices : Array[ChoiceOption]
  mut pending_text_input : (String, String)?
  mut wait_ms : Int
  mut wait_for_click : Bool
  mut wait_custom_name : String?
  mut wait_video : Bool
  mut last_say_proceed_on_done : Bool
  mut ended : Bool
}
pub fn[T] Runtime::choose(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::complete_video_wait(Self[T], Bool) -> RuntimeEvent
pub fn[T : @json.FromJson] Runtime::from_json_string(Script[T], String) -> Self[T] raise
pub fn[T] Runtime::is_waiting(Self[T]) -> Bool
pub fn[T] Runtime::is_waiting_video(Self[T]) -> Bool
pub fn[T] Runtime::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] Runtime::last_say_proceed_on_done(Self[T]) -> Bool
pub fn[T] Runtime::new(Script[T], GameState[T]) -> Self[T]
pub fn[T] Runtime::save(Self[T]) -> RuntimeSave[T]
pub fn[T : ToJson] Runtime::save_json(Self[T]) -> String
pub fn[T] Runtime::skip_wait(Self[T]) -> Unit
pub fn[T] Runtime::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] Runtime::submit_text_input(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError

pub enum RuntimeEvent {
  Noop
  Said(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?)
  IntroShown(String)
  TextBoxShown
  TextBoxHidden
  AvatarShown(String)
  AvatarHidden
  VideoStarted(String, Bool)
  VideoEnded(Bool)
  ChoicePrompt(Array[ChoiceOption])
  TextInputPrompt(String, String)
  BackgroundShown(String)
  BackgroundShownState(BackgroundState)
  FigureShown(String, FigurePlacement)
  FigureHidden(String)
  DomFigureShown(String, FigurePlacement, Bool)
  DomFigureHidden(String)
  DomFigureInteractiveSet(String, Bool)
  MusicPlayed(String, Bool)
  MusicStopped
  SfxPlayed(String, Bool)
  SfxStopped
  CgUnlocked(String)
  AnimatedWebgl(String, AnimationSpec)
  AnimatedDom(String, AnimationSpec)
  EffectApplied(String, EffectSpec)
  Live2dMotionPlayed(String, String, Int?)
  Live2dExpressionSet(String, String?)
  WaitStarted(Int)
  WaitForClickStarted
  WaitCustomEventStarted(String)
  Custom(String, String)
  ScriptEnded
}
pub impl Eq for RuntimeEvent
pub impl Show for RuntimeEvent

pub struct RuntimeSave[T] {
  state : GameState[T]
  ip : Int
  pending_choices : Array[ChoiceOption]
  pending_text_input : (String, String)?
  wait_ms : Int
  wait_for_click : Bool
  wait_custom_name : String?
  wait_video : Bool
  last_say_proceed_on_done : Bool
  ended : Bool
}
pub impl[T : ToJson] ToJson for RuntimeSave[T]
pub impl[T : @json.FromJson] @json.FromJson for RuntimeSave[T]

pub struct SaveSlotEntry {
  slot : String
  meta : SaveSlotMeta?
}
pub impl Eq for SaveSlotEntry
pub impl Show for SaveSlotEntry

pub struct SaveSlotMeta {
  title : String
  preview : String
  updated_at_ms : Double
}
pub impl Eq for SaveSlotMeta
pub impl Show for SaveSlotMeta
pub impl ToJson for SaveSlotMeta
pub impl @json.FromJson for SaveSlotMeta

pub(all) struct ScalarState {
  opacity : Double
  scale : Double
  rotation : Double
  blur : Double
  brightness : Double
  contrast : Double
  saturation : Double
  gamma : Double
  color_r : Double
  color_g : Double
  color_b : Double
}
pub impl Default for ScalarState
pub impl Eq for ScalarState
pub impl Show for ScalarState
pub impl ToJson for ScalarState
pub impl @json.FromJson for ScalarState

pub struct Script[T] {
  instructions : Array[Instruction[T]]
  labels : Map[String, Int]
}

type ScriptBuilder[T]
pub fn[T, A : AnimationTarget] ScriptBuilder::animate(Self[T], A, AnimationSpec) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_blur(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_brightness(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_color_blue(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_color_green(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_color_red(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_contrast(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_gamma(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_opacity(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_position(Self[T], A, Int, from? : Position, Position, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_rotation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_saturation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : AnimationTarget] ScriptBuilder::animate_scale(Self[T], A, Int, from? : Double, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::apply(Self[T], (Self[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::branch(Self[T], Label, Label, (GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::build(Self[T]) -> Script[T] raise ScriptBuildError
pub fn[T] ScriptBuilder::choice(Self[T], Array[ChoiceOption]) -> Unit
pub fn[T, A : PixiTarget] ScriptBuilder::effect(Self[T], A, EffectSpec) -> Unit
pub fn[T, A : PixiTarget] ScriptBuilder::effect_with(Self[T], A, Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::hide_avatar(Self[T]) -> Unit
pub fn[T, F : Figure] ScriptBuilder::hide_figure(Self[T], F) -> Unit
pub fn[T] ScriptBuilder::hide_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::input_text(Self[T], String, String) -> Unit
pub fn[T] ScriptBuilder::intro(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::jump(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::jump_if(Self[T], Label, (GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::label(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::load_text(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::menu(Self[T], String, String, Array[ChoiceOption]) -> Unit
pub fn[T] ScriptBuilder::narrate(Self[T], String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::new() -> Self[T]
pub fn[T] ScriptBuilder::play_live2d_motion(Self[T], Live2dFigure, String, index? : Int) -> Unit
pub fn[T] ScriptBuilder::play_music(Self[T], Music, Bool) -> Unit
pub fn[T] ScriptBuilder::play_sfx(Self[T], Sfx, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::play_video(Self[T], String, can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::run_code(Self[T], (GameState[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::say(Self[T], String, String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::say_many(Self[T], String, Array[String], typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::scene(Self[T], Background, scalars? : ScalarState) -> Unit
pub fn[T] ScriptBuilder::set_figure_interactive(Self[T], DomFigure, Bool) -> Unit
pub fn[T] ScriptBuilder::set_live2d_expression(Self[T], Live2dFigure, id? : String) -> Unit
pub fn[T] ScriptBuilder::show_avatar(Self[T], String) -> Unit
pub fn[T, F : Figure] ScriptBuilder::show_figure(Self[T], F, FigurePlacement, interactive? : Bool) -> Unit
pub fn[T, F : Figure] ScriptBuilder::show_figure_at(Self[T], F, Position, layer? : Int, scalars? : ScalarState, interactive? : Bool) -> Unit
pub fn[T] ScriptBuilder::show_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::stop_music(Self[T]) -> Unit
pub fn[T] ScriptBuilder::unlock_cg(Self[T], GalleryImage) -> Unit
pub fn[T] ScriptBuilder::wait(Self[T], Int) -> Unit
pub fn[T] ScriptBuilder::wait_click(Self[T]) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event(Self[T], String, (GameState[T], String) -> Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event_jump(Self[T], String, (GameState[T], String) -> Label) -> Unit

pub enum SettingsContext {
  FromStartMenu
  FromMidgame
}
pub impl Eq for SettingsContext
pub impl Show for SettingsContext

type Sfx

type UiChoiceView
pub impl Eq for UiChoiceView
pub impl Show for UiChoiceView

type UiDom
pub fn UiDom::advance_auto_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_dom_animation_timer(Self, Int) -> Unit
pub fn UiDom::advance_skip_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_typewriter(Self, elapsed_ms~ : Int) -> Bool
pub fn UiDom::clear_game_ui(Self) -> Unit
pub fn UiDom::complete_typewriter(Self) -> Unit
pub fn UiDom::has_active_dom_animations(Self) -> Bool
pub fn UiDom::is_skip_active(Self) -> Bool
pub fn UiDom::is_typewriter_done(Self) -> Bool
pub fn UiDom::mark_all_dirty(Self) -> Unit
pub fn UiDom::mark_auto_advanced(Self) -> Unit
pub fn UiDom::mark_dirty_action_buttons(Self) -> Unit
pub fn UiDom::mark_dirty_choices(Self) -> Unit
pub fn UiDom::mark_dirty_text(Self) -> Unit
pub fn UiDom::mark_dirty_text_input(Self) -> Unit
pub fn UiDom::mark_skip_advanced(Self) -> Unit
pub fn UiDom::set_auto_mode(Self, Bool) -> Unit
pub fn UiDom::set_skip_hold(Self, Bool) -> Unit
pub fn UiDom::set_skip_mode(Self, Bool) -> Unit
pub fn UiDom::set_text_speed(Self, Int) -> Unit
pub fn UiDom::should_auto_advance(Self) -> Bool
pub fn UiDom::should_skip_advance(Self) -> Bool
pub fn UiDom::simulate_click(Self) -> Unit
pub fn UiDom::simulate_intro_done(Self) -> Unit
pub fn UiDom::start_typewriter(Self, String) -> Unit
pub fn UiDom::text_speed_ms_per_char(Self) -> Int
pub fn UiDom::toggle_auto_mode(Self) -> Unit
pub fn UiDom::toggle_skip_mode(Self) -> Unit
pub fn UiDom::typewriter_visible_text(Self) -> StringView

type UiDomFigureView
pub impl Eq for UiDomFigureView
pub impl Show for UiDomFigureView
pub impl ToJson for UiDomFigureView
pub impl @json.FromJson for UiDomFigureView

type UiTextInputView
pub impl Eq for UiTextInputView
pub impl Show for UiTextInputView

type UiVideoView
pub impl Eq for UiVideoView
pub impl Show for UiVideoView

type UiViewModel
pub impl Eq for UiViewModel
pub impl Show for UiViewModel

type Video
pub impl @js.Cast for Video

type WebGL
pub fn WebGL::active_texture(Self, Int) -> Unit
pub fn WebGL::attach_shader(Self, WebGLProgram, WebGLShader) -> Unit
pub fn WebGL::bind_buffer(Self, Int, WebGLBuffer) -> Unit
pub fn WebGL::bind_texture(Self, Int, WebGLTexture) -> Unit
pub fn WebGL::blend_func(Self, Int, Int) -> Unit
pub fn WebGL::buffer_data(Self, Int, @js.Value, Int) -> Unit
pub fn WebGL::clear(Self, Int) -> Unit
pub fn WebGL::clear_color(Self, Double, Double, Double, Double) -> Unit
pub fn WebGL::compile_shader(Self, WebGLShader) -> Unit
pub fn WebGL::constant(Self, String) -> Int
pub fn WebGL::create_buffer(Self) -> WebGLBuffer?
pub fn WebGL::create_program(Self) -> WebGLProgram?
pub fn WebGL::create_shader(Self, Int) -> WebGLShader?
pub fn WebGL::create_texture(Self) -> WebGLTexture?
pub fn WebGL::draw_arrays(Self, Int, Int, Int) -> Unit
pub fn WebGL::draw_elements(Self, Int, Int, Int, Int) -> Unit
pub fn WebGL::enable(Self, Int) -> Unit
pub fn WebGL::enable_vertex_attrib_array(Self, Int) -> Unit
pub fn WebGL::generate_mipmap(Self, Int) -> Unit
pub fn WebGL::get_attrib_location(Self, WebGLProgram, String) -> Int
pub fn WebGL::get_program_info_log(Self, WebGLProgram) -> String
pub fn WebGL::get_program_parameter(Self, WebGLProgram, Int) -> Bool
pub fn WebGL::get_shader_info_log(Self, WebGLShader) -> String
pub fn WebGL::get_shader_parameter(Self, WebGLShader, Int) -> Bool
pub fn WebGL::get_uniform_location(Self, WebGLProgram, String) -> WebGLUniformLocation?
pub fn WebGL::link_program(Self, WebGLProgram) -> Unit
pub fn WebGL::shader_source(Self, WebGLShader, String) -> Unit
pub fn WebGL::tex_image_2d(Self, Int, Int, Int, Int, Int, Int, Int, Int, @js.Value) -> Unit
pub fn WebGL::tex_image_2d_source(Self, Int, Int, Int, Int, Int, @js.Value) -> Unit
pub fn WebGL::tex_param_i(Self, Int, Int, Int) -> Unit
pub fn WebGL::uniform1f(Self, WebGLUniformLocation, Double) -> Unit
pub fn WebGL::uniform1i(Self, WebGLUniformLocation, Int) -> Unit
pub fn WebGL::uniform2f(Self, WebGLUniformLocation, Double, Double) -> Unit
pub fn WebGL::uniform3f(Self, WebGLUniformLocation, Double, Double, Double) -> Unit
pub fn WebGL::uniform4f(Self, WebGLUniformLocation, Double, Double, Double, Double) -> Unit
pub fn WebGL::uniform_matrix4(Self, WebGLUniformLocation, Bool, @js.Value) -> Unit
pub fn WebGL::use_program(Self, WebGLProgram) -> Unit
pub fn WebGL::vertex_attrib_pointer(Self, Int, Int, Int, Bool, Int, Int) -> Unit
pub fn WebGL::viewport(Self, Int, Int, Int, Int) -> Unit

type WebGLBuffer

type WebGLProgram

type WebGLShader

type WebGLTexture

type WebGLUniformLocation

// Type aliases
pub type EffectParam = (String, Double)

pub type EventHook = (RuntimeEvent) -> Unit

pub type PayloadJumpSelector[T] = (GameState[T], String) -> Label

pub type PayloadPredicate[T] = (GameState[T], String) -> Bool

pub type PixiEffectApply = (PixiSprite, Array[(String, Double)], Int) -> Bool

pub type PixiSharedEffectApply = (PixiEffectTarget, Array[(String, Double)], Int) -> Bool

pub type RenderSyncHook[T] = (Director[T]) -> Unit

pub type ScriptFactory[T] = async () -> Script[T]

pub type ScriptHook[T] = (GameState[T]) -> Unit

pub type ScriptPredicate[T] = (GameState[T]) -> Bool

// Traits
trait AnimationTarget

trait Figure : AnimationTarget

trait PixiTarget : AnimationTarget

