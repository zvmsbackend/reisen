// Generated using `moon info`, DON'T EDIT IT
package "sennenki/reisen"

import {
  "moonbitlang/core/json",
  "sennenki/reisen/assets",
  "sennenki/reisen/core",
  "sennenki/reisen/gallery",
  "sennenki/reisen/pixi",
  "sennenki/reisen/state",
  "sennenki/reisen/storage",
  "sennenki/reisen/ui",
}

// Values
pub fn[T : @json.FromJson] director_from_save_json(@core.Script[T], String) -> Director[T] raise

pub async fn[T] make_pixi_render_sync_hook_from_canvas(String, @assets.AssetStore) -> (async (Director[T]) -> Unit noraise)?

pub async fn[T] make_pixi_render_sync_hook_from_canvas_element(@pixi.PixiCanvas, @assets.AssetStore) -> (async (Director[T]) -> Unit noraise)

pub async fn[T] make_pixi_render_sync_hook_from_canvas_element_with_config(@pixi.PixiCanvas, @assets.AssetStore, PixiPresenterConfig) -> (async (Director[T]) -> Unit noraise)

pub async fn[T] make_pixi_render_sync_hook_from_canvas_with_config(String, @assets.AssetStore, PixiPresenterConfig) -> (async (Director[T]) -> Unit noraise)?

pub fn pixi_presenter_default_config() -> PixiPresenterConfig

pub async fn[T : @json.FromJson + ToJson] run_browser_app_loop(AppController[T]) -> Unit

pub async fn[T] run_browser_loop(GameRunner[T]) -> Unit

pub fn[T : ToJson] save_director_to_slot(Director[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot(GameRunner[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot_with_meta(GameRunner[T], String, title? : String, preview? : String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub async fn[T] start_game(@core.Script[T], @state.GameState[T], String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_save(@core.Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_slot(@core.Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, save_namespace? : String, settings? : @storage.GameSettings, slot_payload_version? : Int) -> GameRunner[T]

pub fn[T] validate_script_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_audio_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_image_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

// Errors
pub suberror AppBootstrapError {
  MissingImageAsset(id~ : String)
  MissingAudioAsset(id~ : String)
  MissingSaveSlot(slot~ : String)
}

pub suberror LogReconstructionError {
  StepLimitExceeded(limit~ : Int)
  MissingChoiceTrace(ip~ : Int)
  MissingCustomJumpTrace(name~ : String, ip~ : Int)
  RuntimeFailure(message~ : String)
}

// Types and methods
type AppController[T]
pub fn[T] AppController::new(async () -> @core.Script[T], () -> @state.GameState[T], String, save_namespace? : String, autosave_slot? : String, autosave_title? : String, menu_background? : String, settings_background? : String, gallery_background? : String, menu_music? : @assets.Music, menu_music_loop? : Bool, start_logo_urls? : Array[String], start_logo_duration_ms? : Int, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, gallery_replay_state_factories? : @gallery.ReplayStateFactories[T]) -> Self[T]
pub fn[T] AppController::phase(Self[T]) -> AppPhase
pub fn[T] AppController::submit_custom_event(Self[T], String, String) -> Bool
pub async fn[T : @json.FromJson + ToJson] AppController::tick(Self[T], elapsed_ms? : Int) -> Bool

pub enum AppPhase {
  StartGate
  StartLogo
  StartMenu
  Gallery
  Settings
  InGame
}
pub impl Eq for AppPhase
pub impl Show for AppPhase

type DialogLine
pub impl Eq for DialogLine
pub impl Show for DialogLine
pub impl ToJson for DialogLine
pub impl @json.FromJson for DialogLine

type Director[T]
pub fn[T] Director::animations(Self[T]) -> Array[(String, @core.AnimationSpec)]
pub fn[T] Director::avatar_id(Self[T]) -> String?
pub fn[T] Director::background(Self[T]) -> String?
pub fn[T] Director::background_state(Self[T]) -> @core.BackgroundState?
pub fn[T] Director::can_auto_skip_wait_click(Self[T]) -> Bool
pub fn[T] Director::can_skip_wait(Self[T]) -> Bool
pub fn[T] Director::choices(Self[T]) -> Array[@core.ChoiceOption]
pub fn[T] Director::choose(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::clear_dialog(Self[T]) -> Unit
pub fn[T] Director::clear_render(Self[T]) -> Unit
pub fn[T] Director::complete_video_wait(Self[T], Bool) -> @core.RuntimeEvent
pub fn[T] Director::dialog(Self[T]) -> DialogLine?
pub fn[T] Director::dialog_history(Self[T]) -> Array[@core.DialogLogEntry]
pub fn[T] Director::dialog_seq(Self[T]) -> Int
pub fn[T] Director::dom_animations(Self[T]) -> Array[(String, @core.AnimationSpec)]
pub fn[T] Director::dom_figures(Self[T]) -> Map[String, @core.DomFigureState]
pub fn[T] Director::effects(Self[T], String) -> Array[@core.EffectSpec]
pub fn[T] Director::figure(Self[T], String) -> @core.FigurePlacement?
pub fn[T] Director::figures(Self[T]) -> Map[String, @core.FigurePlacement]
pub fn[T] Director::flow_trace(Self[T]) -> Array[@core.ScriptFlowTrace]
pub fn[T] Director::from_save(@core.Script[T], DirectorSave[T]) -> Self[T] raise @core.ScriptRuntimeError
pub fn[T] Director::intro_text(Self[T]) -> String?
pub fn[T] Director::is_waiting(Self[T]) -> Bool
pub fn[T] Director::is_waiting_video(Self[T]) -> Bool
pub fn[T] Director::jump_to_label(Self[T], String) -> Unit raise @core.ScriptRuntimeError
pub fn[T] Director::last_sfx(Self[T]) -> String?
pub fn[T] Director::live2d_expressions(Self[T]) -> Array[(String, String?)]
pub fn[T] Director::live2d_motions(Self[T]) -> Array[(String, String, Int?)]
pub fn[T] Director::music(Self[T]) -> (String, Bool)?
pub fn[T] Director::new(@core.Runtime[T]) -> Self[T]
pub fn[T] Director::render_epoch(Self[T]) -> String
pub fn[T] Director::runtime_ip(Self[T]) -> Int
pub fn[T : ToJson] Director::save_json(Self[T]) -> String
pub fn[T] Director::set_background_state(Self[T], @core.BackgroundState) -> Unit
pub fn[T] Director::set_dialog_history(Self[T], Array[@core.DialogLogEntry]) -> Unit
pub fn[T] Director::skip_wait(Self[T]) -> Unit
pub fn[T] Director::step(Self[T], elapsed_ms? : Int) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::submit_custom_event(Self[T], String, String) -> @core.RuntimeEvent
pub fn[T] Director::submit_text_input(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::take_interrupted_sfx(Self[T]) -> String?
pub fn[T] Director::text_box_visible(Self[T]) -> Bool
pub fn[T] Director::text_input(Self[T]) -> (String, String)?
pub fn[T] Director::ui_snapshot(Self[T]) -> @core.UiSnapshot
pub fn[T] Director::video(Self[T]) -> (String, Bool)?

pub struct DirectorSave[T] {
  runtime : @core.RuntimeSave[T]
  render : RenderState
  dialog : DialogLine?
  dialog_seq : Int
  intro_text : String?
  video : (String, Bool)?
  text_box_visible : Bool
  avatar_id : String?
}
pub impl[T : ToJson] ToJson for DirectorSave[T]
pub impl[T : @json.FromJson] @json.FromJson for DirectorSave[T]

type GameRunner[T]
pub fn[T] GameRunner::apply_runtime_event(Self[T], @core.RuntimeEvent) -> Unit
pub fn[T] GameRunner::apply_settings(Self[T], @storage.GameSettings) -> Unit
pub async fn[T] GameRunner::clear_presentation(Self[T]) -> Unit
pub fn[T] GameRunner::clear_ui(Self[T]) -> Unit
pub fn[T] GameRunner::complete_typewriter(Self[T]) -> Unit
pub fn[T] GameRunner::dialog_history(Self[T]) -> Array[@core.DialogLogEntry]
pub fn[T] GameRunner::director(Self[T]) -> Director[T]
pub fn[T] GameRunner::flow_trace(Self[T]) -> Array[@core.ScriptFlowTrace]
pub fn[T] GameRunner::is_log_visible(Self[T]) -> Bool
pub fn[T] GameRunner::jump_to_label(Self[T], String) -> Unit raise @core.ScriptRuntimeError
pub fn[T] GameRunner::log_build_state(Self[T]) -> LogBuildState
pub fn[T] GameRunner::new(Director[T], @ui.UiDom) -> Self[T]
pub fn[T] GameRunner::new_with_hooks(Director[T], @ui.UiDom, async (Director[T]) -> Unit noraise, (@core.RuntimeEvent) -> Unit) -> Self[T]
pub fn[T] GameRunner::new_with_render_sync(Director[T], @ui.UiDom, async (Director[T]) -> Unit noraise) -> Self[T]
pub fn[T] GameRunner::reconstruct_dialog_history(Self[T], @core.Script[T], @state.GameState[T], max_steps? : Int) -> Unit raise LogReconstructionError
pub fn[T] GameRunner::set_log_build_state(Self[T], LogBuildState) -> Unit
pub fn[T] GameRunner::set_log_visible(Self[T], Bool) -> Unit
pub fn[T] GameRunner::simulate_click(Self[T]) -> Unit
pub fn[T] GameRunner::start_reconstruct_dialog_history(Self[T], @core.Script[T], @state.GameState[T], max_steps? : Int) -> Unit
pub async fn[T] GameRunner::step(Self[T], elapsed_ms? : Int) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] GameRunner::submit_choice(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] GameRunner::submit_custom_event(Self[T], String, String) -> @core.RuntimeEvent
pub async fn[T] GameRunner::sync_ui(Self[T]) -> Unit
pub fn[T] GameRunner::take_game_action(Self[T]) -> String?
pub fn[T] GameRunner::take_pending_action(Self[T]) -> String?
pub async fn[T] GameRunner::tick(Self[T], elapsed_ms? : Int) -> Bool
pub fn[T] GameRunner::toggle_auto_mode(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_log_visible(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_skip_mode(Self[T]) -> Unit

pub enum LogBuildState {
  NotBuilt
  Building
  Ready
}
pub impl Eq for LogBuildState
pub impl Show for LogBuildState

pub struct PixiPresenterConfig {
  antialias : Bool
  background_alpha : Double
  resolution : Double
  auto_density : Bool
  position_entry_offset_ratio : Double
  scale_entry_from : Double
}
pub impl Eq for PixiPresenterConfig
pub impl Show for PixiPresenterConfig

pub struct RenderState {
  mut background : @core.BackgroundState?
  figures : Map[String, @core.FigurePlacement]
  dom_figures : Map[String, @core.DomFigureState]
  mut music : (String, Bool)?
  mut last_sfx : String?
  mut last_sfx_interrupted : Bool
  pixi_animations : Array[(String, @core.AnimationSpec)]
  dom_animations : Array[(String, @core.AnimationSpec)]
  effects : Map[String, Array[@core.EffectSpec]]
  live2d_motions : Array[(String, String, Int?)]
  live2d_expressions : Array[(String, String?)]
  render_epoch : String
}
pub impl ToJson for RenderState
pub impl @json.FromJson for RenderState

pub struct SaveSlotPayload {
  version : Int
  director_json : String
}
pub impl ToJson for SaveSlotPayload
pub impl @json.FromJson for SaveSlotPayload

// Type aliases
pub type RenderSyncHook[T] = async (Director[T]) -> Unit noraise

pub type ScriptFactory[T] = async () -> @core.Script[T]

// Traits

