// Generated using `moon info`, DON'T EDIT IT
package "sennenki/reisen"

import {
  "moonbit-community/js-ffi/js",
  "moonbitlang/core/json",
  "sennenki/reisen/assets",
  "sennenki/reisen/core",
  "sennenki/reisen/gallery",
  "sennenki/reisen/state",
  "sennenki/reisen/storage",
}

// Values
pub fn anim_blur(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_brightness(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_color_blue(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_color_green(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_color_red(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_contrast(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_gamma(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_opacity(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_position(Int, @core.Position?, @core.Position, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_rotation(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_saturation(Int, Double?, Double, easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn anim_scale(Int, Double?, Double, anchor? : (Double, Double), easing? : @core.Easing, blocking? : Bool) -> @core.AnimationSpec

pub fn audio_dom_has_active_sfx() -> Bool

pub fn[T : @json.FromJson] director_from_save_json(@core.Script[T], String) -> Director[T] raise

pub fn effect_spec(Effect, Array[(String, Double)], phase? : @core.EffectPhase, duration_ms? : Int, blocking? : Bool, easing? : @core.Easing) -> @core.EffectSpec

pub fn get_canvas_by_id(String) -> PixiCanvas?

pub fn[T] make_pixi_render_sync_hook_from_canvas(String, @assets.AssetStore) -> (async (Director[T]) -> Unit noraise)?

pub fn[T] make_pixi_render_sync_hook_from_canvas_element(PixiCanvas, @assets.AssetStore) -> async (Director[T]) -> Unit noraise

pub fn[T] make_pixi_render_sync_hook_from_canvas_element_with_config(PixiCanvas, @assets.AssetStore, PixiPresenterConfig) -> async (Director[T]) -> Unit noraise

pub fn[T] make_pixi_render_sync_hook_from_canvas_with_config(String, @assets.AssetStore, PixiPresenterConfig) -> (async (Director[T]) -> Unit noraise)?

pub fn option(String, @core.Label, id? : String) -> @core.ChoiceOption

pub async fn pixi_assets_load_texture(String) -> PixiTexture raise PixiBindingError

pub async fn pixi_load_live2d_model(String) -> PixiLive2dModel raise PixiBindingError

pub fn pixi_new_application() -> PixiApplication

pub fn pixi_new_blur_filter() -> PixiBlurFilter

pub fn pixi_new_color_matrix_filter() -> PixiColorMatrixFilter

pub fn pixi_new_container() -> PixiContainer

pub fn pixi_new_filter(String, String) -> PixiFilter

pub fn pixi_new_sprite(PixiTexture) -> PixiSprite

pub fn pixi_presenter_default_config() -> PixiPresenterConfig

pub fn pixi_texture_from(@js.Value) -> PixiTexture

pub fn place_center(layer? : Int, scalars? : @core.ScalarState) -> @core.FigurePlacement

pub fn place_custom(Double, Double, layer? : Int, scalars? : @core.ScalarState) -> @core.FigurePlacement

pub fn place_left(layer? : Int, scalars? : @core.ScalarState) -> @core.FigurePlacement

pub fn place_right(layer? : Int, scalars? : @core.ScalarState) -> @core.FigurePlacement

pub fn register_pixi_effect((PixiSprite, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn register_pixi_effect_shared((PixiEffectTarget, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn[T] reisen_parse_text_script(String) -> @core.Script[T] raise @core.ScriptBuildError

pub async fn[T : @json.FromJson + ToJson] run_browser_app_loop(AppController[T]) -> Unit

pub async fn[T] run_browser_loop(GameRunner[T]) -> Unit

pub fn[T : ToJson] save_director_to_slot(Director[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot(GameRunner[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot_with_meta(GameRunner[T], String, title? : String, preview? : String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T] script((ScriptBuilder[T]) -> Unit) -> @core.Script[T] raise @core.ScriptBuildError

pub async fn[T] start_game(@core.Script[T], @state.GameState[T], String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_save(@core.Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_slot(@core.Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, save_namespace? : String, settings? : @storage.GameSettings, slot_payload_version? : Int) -> GameRunner[T]

pub fn[T] validate_script_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_audio_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_image_assets(@core.Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn window_inner_height() -> Double

pub fn window_inner_width() -> Double

// Errors
pub suberror AppBootstrapError {
  MissingImageAsset(id~ : String)
  MissingAudioAsset(id~ : String)
  MissingSaveSlot(slot~ : String)
}

pub suberror LogReconstructionError {
  StepLimitExceeded(limit~ : Int)
  MissingChoiceTrace(ip~ : Int)
  MissingCustomJumpTrace(name~ : String, ip~ : Int)
  RuntimeFailure(message~ : String)
}

pub suberror PixiBindingError {
  ResourceLoadFailed(message~ : String)
}

pub suberror ReisenTextError {
}
pub impl Eq for ReisenTextError
pub impl Show for ReisenTextError

// Types and methods
type AppController[T]
pub fn[T] AppController::new(async () -> @core.Script[T], () -> @state.GameState[T], String, save_namespace? : String, autosave_slot? : String, autosave_title? : String, menu_background? : String, settings_background? : String, gallery_background? : String, menu_music? : @assets.Music, menu_music_loop? : Bool, start_logo_urls? : Array[String], start_logo_duration_ms? : Int, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (@core.RuntimeEvent) -> Unit, gallery_replay_state_factories? : @gallery.ReplayStateFactories[T]) -> Self[T]
pub fn[T] AppController::phase(Self[T]) -> AppPhase
pub fn[T] AppController::submit_custom_event(Self[T], String, String) -> Bool
pub async fn[T : @json.FromJson + ToJson] AppController::tick(Self[T], elapsed_ms? : Int) -> Bool

pub enum AppPhase {
  StartGate
  StartLogo
  StartMenu
  Gallery
  Settings
  InGame
}
pub impl Eq for AppPhase
pub impl Show for AppPhase

type AudioCommand
pub impl Eq for AudioCommand
pub impl Show for AudioCommand

type AudioDom
pub fn AudioDom::apply_settings(Self, @storage.GameSettings) -> Unit
pub fn AudioDom::as_event_hook(Self) -> (@core.RuntimeEvent) -> Unit
pub fn AudioDom::handle_event(Self, @core.RuntimeEvent) -> Unit
pub fn AudioDom::new((String) -> String?) -> Self
pub fn AudioDom::new_with_store(@assets.AssetStore) -> Self
pub fn AudioDom::set_bgm_gain(Self, Double) -> Unit
pub fn AudioDom::set_sfx_gain(Self, Double) -> Unit

type DialogLine
pub impl Eq for DialogLine
pub impl Show for DialogLine
pub impl ToJson for DialogLine
pub impl @json.FromJson for DialogLine

pub struct DialogLogEntry {
  speaker : String
  text : String
}
pub impl Eq for DialogLogEntry
pub impl Show for DialogLogEntry
pub impl ToJson for DialogLogEntry
pub impl @json.FromJson for DialogLogEntry

type Director[T]
pub fn[T] Director::animations(Self[T]) -> Array[(String, @core.AnimationSpec)]
pub fn[T] Director::avatar_id(Self[T]) -> String?
pub fn[T] Director::background(Self[T]) -> String?
pub fn[T] Director::background_state(Self[T]) -> @core.BackgroundState?
pub fn[T] Director::can_auto_skip_wait_click(Self[T]) -> Bool
pub fn[T] Director::can_skip_wait(Self[T]) -> Bool
pub fn[T] Director::choices(Self[T]) -> Array[@core.ChoiceOption]
pub fn[T] Director::choose(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::clear_dialog(Self[T]) -> Unit
pub fn[T] Director::clear_render(Self[T]) -> Unit
pub fn[T] Director::complete_video_wait(Self[T], Bool) -> @core.RuntimeEvent
pub fn[T] Director::dialog(Self[T]) -> DialogLine?
pub fn[T] Director::dialog_history(Self[T]) -> Array[DialogLogEntry]
pub fn[T] Director::dialog_seq(Self[T]) -> Int
pub fn[T] Director::dom_animations(Self[T]) -> Array[(String, @core.AnimationSpec)]
pub fn[T] Director::dom_figures(Self[T]) -> Map[String, @core.DomFigureState]
pub fn[T] Director::effects(Self[T], String) -> Array[@core.EffectSpec]
pub fn[T] Director::figure(Self[T], String) -> @core.FigurePlacement?
pub fn[T] Director::figures(Self[T]) -> Map[String, @core.FigurePlacement]
pub fn[T] Director::flow_trace(Self[T]) -> Array[@core.ScriptFlowTrace]
pub fn[T] Director::from_save(@core.Script[T], DirectorSave[T]) -> Self[T] raise @core.ScriptRuntimeError
pub fn[T] Director::intro_text(Self[T]) -> String?
pub fn[T] Director::is_waiting(Self[T]) -> Bool
pub fn[T] Director::is_waiting_video(Self[T]) -> Bool
pub fn[T] Director::jump_to_label(Self[T], String) -> Unit raise @core.ScriptRuntimeError
pub fn[T] Director::last_sfx(Self[T]) -> String?
pub fn[T] Director::live2d_expressions(Self[T]) -> Array[(String, String?)]
pub fn[T] Director::live2d_motions(Self[T]) -> Array[(String, String, Int?)]
pub fn[T] Director::music(Self[T]) -> (String, Bool)?
pub fn[T] Director::new(@core.Runtime[T]) -> Self[T]
pub fn[T] Director::render_epoch(Self[T]) -> String
pub fn[T] Director::runtime_ip(Self[T]) -> Int
pub fn[T : ToJson] Director::save_json(Self[T]) -> String
pub fn[T] Director::set_background_state(Self[T], @core.BackgroundState) -> Unit
pub fn[T] Director::set_dialog_history(Self[T], Array[DialogLogEntry]) -> Unit
pub fn[T] Director::skip_wait(Self[T]) -> Unit
pub fn[T] Director::step(Self[T], elapsed_ms? : Int) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::submit_custom_event(Self[T], String, String) -> @core.RuntimeEvent
pub fn[T] Director::submit_text_input(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] Director::take_interrupted_sfx(Self[T]) -> String?
pub fn[T] Director::text_box_visible(Self[T]) -> Bool
pub fn[T] Director::text_input(Self[T]) -> (String, String)?
pub fn[T] Director::video(Self[T]) -> (String, Bool)?

pub struct DirectorSave[T] {
  runtime : @core.RuntimeSave[T]
  render : RenderState
  dialog : DialogLine?
  dialog_seq : Int
  intro_text : String?
  video : (String, Bool)?
  text_box_visible : Bool
  avatar_id : String?
}
pub impl[T : ToJson] ToJson for DirectorSave[T]
pub impl[T : @json.FromJson] @json.FromJson for DirectorSave[T]

type Effect

type GalleryTileView
pub impl Eq for GalleryTileView
pub impl Show for GalleryTileView
pub impl ToJson for GalleryTileView
pub impl @json.FromJson for GalleryTileView

type GameRunner[T]
pub fn[T] GameRunner::apply_runtime_event(Self[T], @core.RuntimeEvent) -> Unit
pub fn[T] GameRunner::apply_settings(Self[T], @storage.GameSettings) -> Unit
pub async fn[T] GameRunner::clear_presentation(Self[T]) -> Unit
pub fn[T] GameRunner::clear_ui(Self[T]) -> Unit
pub fn[T] GameRunner::complete_typewriter(Self[T]) -> Unit
pub fn[T] GameRunner::dialog_history(Self[T]) -> Array[DialogLogEntry]
pub fn[T] GameRunner::director(Self[T]) -> Director[T]
pub fn[T] GameRunner::flow_trace(Self[T]) -> Array[@core.ScriptFlowTrace]
pub fn[T] GameRunner::is_log_visible(Self[T]) -> Bool
pub fn[T] GameRunner::jump_to_label(Self[T], String) -> Unit raise @core.ScriptRuntimeError
pub fn[T] GameRunner::log_build_state(Self[T]) -> LogBuildState
pub fn[T] GameRunner::new(Director[T], UiDom) -> Self[T]
pub fn[T] GameRunner::new_with_hooks(Director[T], UiDom, async (Director[T]) -> Unit noraise, (@core.RuntimeEvent) -> Unit) -> Self[T]
pub fn[T] GameRunner::new_with_render_sync(Director[T], UiDom, async (Director[T]) -> Unit noraise) -> Self[T]
pub fn[T] GameRunner::reconstruct_dialog_history(Self[T], @core.Script[T], @state.GameState[T], max_steps? : Int) -> Unit raise LogReconstructionError
pub fn[T] GameRunner::set_log_build_state(Self[T], LogBuildState) -> Unit
pub fn[T] GameRunner::set_log_visible(Self[T], Bool) -> Unit
pub fn[T] GameRunner::simulate_click(Self[T]) -> Unit
pub fn[T] GameRunner::start_reconstruct_dialog_history(Self[T], @core.Script[T], @state.GameState[T], max_steps? : Int) -> Unit
pub async fn[T] GameRunner::step(Self[T], elapsed_ms? : Int) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] GameRunner::submit_choice(Self[T], String) -> @core.RuntimeEvent raise @core.ScriptRuntimeError
pub fn[T] GameRunner::submit_custom_event(Self[T], String, String) -> @core.RuntimeEvent
pub async fn[T] GameRunner::sync_ui(Self[T]) -> Unit
pub fn[T] GameRunner::take_game_action(Self[T]) -> String?
pub fn[T] GameRunner::take_pending_action(Self[T]) -> String?
pub async fn[T] GameRunner::tick(Self[T], elapsed_ms? : Int) -> Bool
pub fn[T] GameRunner::toggle_auto_mode(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_log_visible(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_skip_mode(Self[T]) -> Unit

pub enum LogBuildState {
  NotBuilt
  Building
  Ready
}
pub impl Eq for LogBuildState
pub impl Show for LogBuildState

type PixiApplication
pub async fn PixiApplication::init_with_canvas(Self, @js.Value, Int, Int, antialias? : Bool, background_alpha? : Double, resolution? : Double, auto_density? : Bool) -> Unit

type PixiBlurFilter

type PixiCanvas

type PixiColorMatrixFilter

type PixiContainer

pub enum PixiEffectTarget {
  Sprite(PixiSprite)
  Live2d(PixiLive2dModel)
}

type PixiFilter

type PixiLive2dModel
pub fn PixiLive2dModel::destroy(Self) -> Unit
pub async fn PixiLive2dModel::expression(Self, id? : String) -> Bool
pub fn PixiLive2dModel::focus(Self, Double, Double, instant? : Bool) -> Unit
pub fn PixiLive2dModel::height(Self) -> Double
pub async fn PixiLive2dModel::motion(Self, String, index? : Int) -> Bool noraise
pub fn PixiLive2dModel::set_alpha(Self, Double) -> Unit
pub fn PixiLive2dModel::set_anchor(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_expression(Self, @js.Optional[String]) -> Unit
pub fn PixiLive2dModel::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiLive2dModel::set_interactive(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_position(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_rotation(Self, Double) -> Unit
pub fn PixiLive2dModel::set_scale(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_size(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_visible(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_z_index(Self, Int) -> Unit
pub fn PixiLive2dModel::width(Self) -> Double

pub struct PixiPresenterConfig {
  antialias : Bool
  background_alpha : Double
  resolution : Double
  auto_density : Bool
  position_entry_offset_ratio : Double
  scale_entry_from : Double
}
pub impl Eq for PixiPresenterConfig
pub impl Show for PixiPresenterConfig

type PixiSprite
pub fn PixiSprite::set_alpha(Self, Double) -> Unit
pub fn PixiSprite::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiSprite::set_position(Self, Double, Double) -> Unit
pub fn PixiSprite::set_rotation(Self, Double) -> Unit
pub fn PixiSprite::set_scale(Self, Double, Double) -> Unit
pub fn PixiSprite::set_tint(Self, Int) -> Unit

type PixiTexture

pub struct RenderState {
  mut background : @core.BackgroundState?
  figures : Map[String, @core.FigurePlacement]
  dom_figures : Map[String, @core.DomFigureState]
  mut music : (String, Bool)?
  mut last_sfx : String?
  mut last_sfx_interrupted : Bool
  pixi_animations : Array[(String, @core.AnimationSpec)]
  dom_animations : Array[(String, @core.AnimationSpec)]
  effects : Map[String, Array[@core.EffectSpec]]
  live2d_motions : Array[(String, String, Int?)]
  live2d_expressions : Array[(String, String?)]
  render_epoch : String
}
pub impl ToJson for RenderState
pub impl @json.FromJson for RenderState

pub struct SaveSlotPayload {
  version : Int
  director_json : String
}
pub impl ToJson for SaveSlotPayload
pub impl @json.FromJson for SaveSlotPayload

type ScriptBuilder[T]
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate(Self[T], A, @core.AnimationSpec) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_blur(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_brightness(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_blue(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_green(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_red(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_contrast(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_gamma(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_opacity(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_position(Self[T], A, Int, from? : @core.Position, @core.Position, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_rotation(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_saturation(Self[T], A, Int, from? : Double, Double, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_scale(Self[T], A, Int, from? : Double, Double, anchor? : (Double, Double), easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::apply(Self[T], (Self[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::branch(Self[T], @core.Label, @core.Label, (@state.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::build(Self[T]) -> @core.Script[T] raise @core.ScriptBuildError
pub fn[T] ScriptBuilder::choice(Self[T], Array[@core.ChoiceOption]) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect(Self[T], A, @core.EffectSpec) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect_with(Self[T], A, Effect, Array[(String, Double)], phase? : @core.EffectPhase, duration_ms? : Int, easing? : @core.Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::hide_avatar(Self[T]) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::hide_figure(Self[T], F) -> Unit
pub fn[T] ScriptBuilder::hide_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::input_text(Self[T], String, String) -> Unit
pub fn[T] ScriptBuilder::intro(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::jump(Self[T], @core.Label) -> Unit
pub fn[T] ScriptBuilder::jump_if(Self[T], @core.Label, (@state.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::label(Self[T], @core.Label) -> Unit
pub fn[T] ScriptBuilder::load_text(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::menu(Self[T], String, String, Array[@core.ChoiceOption]) -> Unit
pub fn[T] ScriptBuilder::narrate(Self[T], String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::new() -> Self[T]
pub fn[T] ScriptBuilder::play_live2d_motion(Self[T], @assets.Live2dFigure, String, index? : Int) -> Unit
pub fn[T] ScriptBuilder::play_music(Self[T], @assets.Music, Bool) -> Unit
pub fn[T] ScriptBuilder::play_sfx(Self[T], @assets.Sfx, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::play_video(Self[T], String, can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::run_code(Self[T], (@state.GameState[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::say(Self[T], String, String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::say_many(Self[T], String, Array[String], typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::scene(Self[T], @assets.Background, scalars? : @core.ScalarState) -> Unit
pub fn[T] ScriptBuilder::set_figure_interactive(Self[T], @assets.DomFigure, Bool) -> Unit
pub fn[T] ScriptBuilder::set_live2d_expression(Self[T], @assets.Live2dFigure, id? : String) -> Unit
pub fn[T] ScriptBuilder::show_avatar(Self[T], String) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure(Self[T], F, @core.FigurePlacement, interactive? : Bool) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure_at(Self[T], F, @core.Position, layer? : Int, scalars? : @core.ScalarState, interactive? : Bool) -> Unit
pub fn[T] ScriptBuilder::show_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::stop_music(Self[T]) -> Unit
pub fn[T] ScriptBuilder::unlock_cg(Self[T], @gallery.GalleryImage) -> Unit
pub fn[T] ScriptBuilder::wait(Self[T], Int) -> Unit
pub fn[T] ScriptBuilder::wait_click(Self[T], can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event(Self[T], String, (@state.GameState[T], String) -> Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event_jump(Self[T], String, (@state.GameState[T], String) -> @core.Label) -> Unit

pub enum SettingsContext {
  FromStartMenu
  FromMidgame
}
pub impl Eq for SettingsContext
pub impl Show for SettingsContext

type UiChoiceView
pub impl Eq for UiChoiceView
pub impl Show for UiChoiceView

type UiDom
pub fn UiDom::advance_auto_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_dom_animation_timer(Self, Int) -> Unit
pub fn UiDom::advance_skip_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_typewriter(Self, elapsed_ms~ : Int) -> Bool
pub fn UiDom::clear_game_ui(Self) -> Unit
pub fn UiDom::complete_typewriter(Self) -> Unit
pub fn UiDom::has_active_dom_animations(Self) -> Bool
pub fn UiDom::is_log_building(Self) -> Bool
pub fn UiDom::is_log_visible(Self) -> Bool
pub fn UiDom::is_skip_active(Self) -> Bool
pub fn UiDom::is_typewriter_done(Self) -> Bool
pub fn UiDom::mark_all_dirty(Self) -> Unit
pub fn UiDom::mark_auto_advanced(Self) -> Unit
pub fn UiDom::mark_dirty_action_buttons(Self) -> Unit
pub fn UiDom::mark_dirty_choices(Self) -> Unit
pub fn UiDom::mark_dirty_text(Self) -> Unit
pub fn UiDom::mark_dirty_text_input(Self) -> Unit
pub fn UiDom::mark_skip_advanced(Self) -> Unit
pub fn UiDom::set_auto_mode(Self, Bool) -> Unit
pub fn UiDom::set_log_building(Self, Bool) -> Unit
pub fn UiDom::set_log_visible(Self, Bool) -> Unit
pub fn UiDom::set_media_volume(Self, Double) -> Unit
pub fn UiDom::set_skip_hold(Self, Bool) -> Unit
pub fn UiDom::set_skip_mode(Self, Bool) -> Unit
pub fn UiDom::set_text_speed(Self, Int) -> Unit
pub fn UiDom::should_auto_advance(Self) -> Bool
pub fn UiDom::should_auto_skip_wait_click(Self) -> Bool
pub fn UiDom::should_skip_advance(Self) -> Bool
pub fn UiDom::simulate_click(Self) -> Unit
pub fn UiDom::simulate_intro_done(Self) -> Unit
pub fn UiDom::start_typewriter(Self, String) -> Unit
pub fn UiDom::text_speed_ms_per_char(Self) -> Int
pub fn UiDom::toggle_auto_mode(Self) -> Unit
pub fn UiDom::toggle_log_visible(Self) -> Unit
pub fn UiDom::toggle_skip_mode(Self) -> Unit
pub fn UiDom::typewriter_visible_text(Self) -> StringView

type UiDomFigureView
pub impl Eq for UiDomFigureView
pub impl Show for UiDomFigureView
pub impl ToJson for UiDomFigureView
pub impl @json.FromJson for UiDomFigureView

type UiTextInputView
pub impl Eq for UiTextInputView
pub impl Show for UiTextInputView

type UiVideoView
pub impl Eq for UiVideoView
pub impl Show for UiVideoView

type UiViewModel
pub impl Eq for UiViewModel
pub impl Show for UiViewModel

// Type aliases
pub type EventHook = (@core.RuntimeEvent) -> Unit

pub type PixiEffectApply = (PixiSprite, Array[(String, Double)], Int) -> Bool

pub type PixiSharedEffectApply = (PixiEffectTarget, Array[(String, Double)], Int) -> Bool

pub type RenderSyncHook[T] = async (Director[T]) -> Unit noraise

pub type ScriptFactory[T] = async () -> @core.Script[T]

// Traits

