// Generated using `moon info`, DON'T EDIT IT
package "sennenki/reisen"

import {
  "moonbit-community/js-ffi/js",
  "moonbitlang/core/json",
  "sennenki/reisen/assets",
  "sennenki/reisen/core",
  "sennenki/reisen/gallery",
  "sennenki/reisen/storage",
}

// Values
pub fn anim_blur(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_brightness(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_blue(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_green(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_color_red(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_contrast(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_gamma(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_opacity(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_position(Int, Position?, Position, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_rotation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_saturation(Int, Double?, Double, easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn anim_scale(Int, Double?, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> AnimationSpec

pub fn audio_dom_has_active_sfx() -> Bool

pub fn[T : @json.FromJson] director_from_save_json(Script[T], String) -> Director[T] raise

pub fn effect_spec(Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, blocking? : Bool, easing? : Easing) -> EffectSpec

pub fn get_canvas_by_id(String) -> PixiCanvas?

pub fn label(name? : String) -> Label

pub fn[T] make_pixi_render_sync_hook_from_canvas(String, @assets.AssetStore) -> (async (Director[T]) -> Unit noraise)?

pub fn[T] make_pixi_render_sync_hook_from_canvas_element(PixiCanvas, @assets.AssetStore) -> async (Director[T]) -> Unit noraise

pub fn[T] make_pixi_render_sync_hook_from_canvas_element_with_config(PixiCanvas, @assets.AssetStore, PixiPresenterConfig) -> async (Director[T]) -> Unit noraise

pub fn[T] make_pixi_render_sync_hook_from_canvas_with_config(String, @assets.AssetStore, PixiPresenterConfig) -> (async (Director[T]) -> Unit noraise)?

pub fn option(String, Label, id? : String) -> ChoiceOption

pub async fn pixi_assets_load_texture(String) -> PixiTexture raise PixiBindingError

pub async fn pixi_load_live2d_model(String) -> PixiLive2dModel raise PixiBindingError

pub fn pixi_new_application() -> PixiApplication

pub fn pixi_new_blur_filter() -> PixiBlurFilter

pub fn pixi_new_color_matrix_filter() -> PixiColorMatrixFilter

pub fn pixi_new_container() -> PixiContainer

pub fn pixi_new_filter(String, String) -> PixiFilter

pub fn pixi_new_sprite(PixiTexture) -> PixiSprite

pub fn pixi_presenter_default_config() -> PixiPresenterConfig

pub fn pixi_texture_from(@js.Value) -> PixiTexture

pub fn place_center(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_custom(Double, Double, layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_left(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn place_right(layer? : Int, scalars? : ScalarState) -> FigurePlacement

pub fn register_pixi_effect((PixiSprite, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn register_pixi_effect_shared((PixiEffectTarget, Array[(String, Double)], Int) -> Bool, defaults? : Array[(String, Double)], id? : String) -> Effect

pub fn[T] reisen_parse_text_script(String) -> Script[T] raise ScriptBuildError

pub async fn[T : @json.FromJson + ToJson] run_browser_app_loop(AppController[T]) -> Unit

pub async fn[T] run_browser_loop(GameRunner[T]) -> Unit

pub fn[T : ToJson] save_director_to_slot(Director[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot(GameRunner[T], String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T : ToJson] save_runner_to_slot_with_meta(GameRunner[T], String, title? : String, preview? : String, save_namespace? : String, slot_payload_version? : Int) -> Unit

pub fn[T] script((ScriptBuilder[T]) -> Unit) -> Script[T] raise ScriptBuildError

pub fn[T] script_from_instructions(Array[Instruction[T]]) -> Script[T] raise ScriptBuildError

pub async fn[T] start_game(Script[T], @core.GameState[T], String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_save(Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (RuntimeEvent) -> Unit, settings? : @storage.GameSettings) -> GameRunner[T]

pub async fn[T : @json.FromJson] start_game_from_slot(Script[T], String, String, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (RuntimeEvent) -> Unit, save_namespace? : String, settings? : @storage.GameSettings, slot_payload_version? : Int) -> GameRunner[T]

pub fn[T] validate_script_assets(Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_audio_assets(Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn[T] validate_script_image_assets(Script[T], @assets.AssetStore) -> Unit raise AppBootstrapError

pub fn window_inner_height() -> Double

pub fn window_inner_width() -> Double

// Errors
pub suberror AppBootstrapError {
  MissingImageAsset(id~ : String)
  MissingAudioAsset(id~ : String)
  MissingSaveSlot(slot~ : String)
}

pub suberror LogReconstructionError {
  StepLimitExceeded(limit~ : Int)
  MissingChoiceTrace(ip~ : Int)
  MissingCustomJumpTrace(name~ : String, ip~ : Int)
  RuntimeFailure(message~ : String)
}

pub suberror PixiBindingError {
  ResourceLoadFailed(message~ : String)
}

pub suberror ReisenTextError {
}
pub impl Eq for ReisenTextError
pub impl Show for ReisenTextError

pub(all) suberror ScriptBuildError {
  DuplicateLabel(name~ : String)
  MissingJumpTarget(target~ : String)
  MissingChoiceTarget(choice_id~ : String, target~ : String)
  EffectUnsupportedOnDomTarget(target~ : String)
  SetInteractiveUnsupportedOnPixiTarget(target~ : String)
}

pub suberror ScriptRuntimeError {
  LabelNotFound(label~ : String)
  ChoiceNotActive
  ChoiceNotFound(id~ : String)
  InvalidInstructionPointer(ip~ : Int)
}

// Types and methods
pub enum AnimProp {
  Opacity
  Position
  Scale
  Rotation
  Blur
  Brightness
  Contrast
  Saturation
  Gamma
  ColorRed
  ColorGreen
  ColorBlue
}
pub impl Eq for AnimProp
pub impl Show for AnimProp
pub impl ToJson for AnimProp
pub impl @json.FromJson for AnimProp

pub struct AnimationSpec {
  prop : AnimProp
  duration_ms : Int
  easing : Easing
  from : Array[Double]?
  to : Array[Double]?
  anchor : Array[Double]?
  blocking : Bool
}
pub impl Eq for AnimationSpec
pub impl Show for AnimationSpec
pub impl ToJson for AnimationSpec
pub impl @json.FromJson for AnimationSpec

type AppController[T]
pub fn[T] AppController::new(async () -> Script[T], () -> @core.GameState[T], String, save_namespace? : String, autosave_slot? : String, autosave_title? : String, menu_background? : String, settings_background? : String, gallery_background? : String, menu_music? : @assets.Music, menu_music_loop? : Bool, start_logo_urls? : Array[String], start_logo_duration_ms? : Int, render_sync? : async (Director[T]) -> Unit noraise, event_hook? : (RuntimeEvent) -> Unit, gallery_replay_state_factories? : @gallery.ReplayStateFactories[T]) -> Self[T]
pub fn[T] AppController::phase(Self[T]) -> AppPhase
pub fn[T] AppController::submit_custom_event(Self[T], String, String) -> Bool
pub async fn[T : @json.FromJson + ToJson] AppController::tick(Self[T], elapsed_ms? : Int) -> Bool

pub enum AppPhase {
  StartGate
  StartLogo
  StartMenu
  Gallery
  Settings
  InGame
}
pub impl Eq for AppPhase
pub impl Show for AppPhase

type AudioCommand
pub impl Eq for AudioCommand
pub impl Show for AudioCommand

type AudioDom
pub fn AudioDom::apply_settings(Self, @storage.GameSettings) -> Unit
pub fn AudioDom::as_event_hook(Self) -> (RuntimeEvent) -> Unit
pub fn AudioDom::handle_event(Self, RuntimeEvent) -> Unit
pub fn AudioDom::new((String) -> String?) -> Self
pub fn AudioDom::new_with_store(@assets.AssetStore) -> Self
pub fn AudioDom::set_bgm_gain(Self, Double) -> Unit
pub fn AudioDom::set_sfx_gain(Self, Double) -> Unit

pub struct BackgroundState {
  id : String
  scalars : ScalarState
}
pub impl Eq for BackgroundState
pub impl Show for BackgroundState
pub impl ToJson for BackgroundState
pub impl @json.FromJson for BackgroundState

type ChoiceOption
pub impl Eq for ChoiceOption
pub impl Show for ChoiceOption
pub impl ToJson for ChoiceOption
pub impl @json.FromJson for ChoiceOption

type DialogLine
pub impl Eq for DialogLine
pub impl Show for DialogLine
pub impl ToJson for DialogLine
pub impl @json.FromJson for DialogLine

pub struct DialogLogEntry {
  speaker : String
  text : String
}
pub impl Eq for DialogLogEntry
pub impl Show for DialogLogEntry
pub impl ToJson for DialogLogEntry
pub impl @json.FromJson for DialogLogEntry

type Director[T]
pub fn[T] Director::animations(Self[T]) -> Array[(String, AnimationSpec)]
pub fn[T] Director::avatar_id(Self[T]) -> String?
pub fn[T] Director::background(Self[T]) -> String?
pub fn[T] Director::background_state(Self[T]) -> BackgroundState?
pub fn[T] Director::can_auto_skip_wait_click(Self[T]) -> Bool
pub fn[T] Director::can_skip_wait(Self[T]) -> Bool
pub fn[T] Director::choices(Self[T]) -> Array[ChoiceOption]
pub fn[T] Director::choose(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::clear_dialog(Self[T]) -> Unit
pub fn[T] Director::clear_render(Self[T]) -> Unit
pub fn[T] Director::complete_video_wait(Self[T], Bool) -> RuntimeEvent
pub fn[T] Director::dialog(Self[T]) -> DialogLine?
pub fn[T] Director::dialog_history(Self[T]) -> Array[DialogLogEntry]
pub fn[T] Director::dialog_seq(Self[T]) -> Int
pub fn[T] Director::dom_animations(Self[T]) -> Array[(String, AnimationSpec)]
pub fn[T] Director::dom_figures(Self[T]) -> Map[String, DomFigureState]
pub fn[T] Director::effects(Self[T], String) -> Array[EffectSpec]
pub fn[T] Director::figure(Self[T], String) -> FigurePlacement?
pub fn[T] Director::figures(Self[T]) -> Map[String, FigurePlacement]
pub fn[T] Director::flow_trace(Self[T]) -> Array[ScriptFlowTrace]
pub fn[T] Director::from_save(Script[T], DirectorSave[T]) -> Self[T] raise ScriptRuntimeError
pub fn[T] Director::intro_text(Self[T]) -> String?
pub fn[T] Director::is_waiting(Self[T]) -> Bool
pub fn[T] Director::is_waiting_video(Self[T]) -> Bool
pub fn[T] Director::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] Director::last_sfx(Self[T]) -> String?
pub fn[T] Director::live2d_expressions(Self[T]) -> Array[(String, String?)]
pub fn[T] Director::live2d_motions(Self[T]) -> Array[(String, String, Int?)]
pub fn[T] Director::music(Self[T]) -> (String, Bool)?
pub fn[T] Director::new(Runtime[T]) -> Self[T]
pub fn[T] Director::render_epoch(Self[T]) -> String
pub fn[T] Director::runtime_ip(Self[T]) -> Int
pub fn[T : ToJson] Director::save_json(Self[T]) -> String
pub fn[T] Director::set_background_state(Self[T], BackgroundState) -> Unit
pub fn[T] Director::set_dialog_history(Self[T], Array[DialogLogEntry]) -> Unit
pub fn[T] Director::skip_wait(Self[T]) -> Unit
pub fn[T] Director::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] Director::submit_text_input(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Director::take_interrupted_sfx(Self[T]) -> String?
pub fn[T] Director::text_box_visible(Self[T]) -> Bool
pub fn[T] Director::text_input(Self[T]) -> (String, String)?
pub fn[T] Director::video(Self[T]) -> (String, Bool)?

pub struct DirectorSave[T] {
  runtime : RuntimeSave[T]
  render : RenderState
  dialog : DialogLine?
  dialog_seq : Int
  intro_text : String?
  video : (String, Bool)?
  text_box_visible : Bool
  avatar_id : String?
}
pub impl[T : ToJson] ToJson for DirectorSave[T]
pub impl[T : @json.FromJson] @json.FromJson for DirectorSave[T]

pub struct DomFigureState {
  placement : FigurePlacement
  interactive : Bool
}
pub impl Eq for DomFigureState
pub impl Show for DomFigureState
pub impl ToJson for DomFigureState
pub impl @json.FromJson for DomFigureState

pub(all) enum Easing {
  Linear
  EaseIn
  EaseOut
  EaseInOut
}
pub impl Eq for Easing
pub impl Show for Easing
pub impl ToJson for Easing
pub impl @json.FromJson for Easing

type Effect

pub(all) enum EffectPhase {
  Pre
  Post
}
pub impl Eq for EffectPhase
pub impl Show for EffectPhase
pub impl ToJson for EffectPhase
pub impl @json.FromJson for EffectPhase

pub struct EffectSpec {
  id : String
  params : Array[(String, Double)]
  phase : EffectPhase
  duration_ms : Int?
  easing : Easing
  blocking : Bool
}
pub impl Eq for EffectSpec
pub impl Show for EffectSpec
pub impl ToJson for EffectSpec
pub impl @json.FromJson for EffectSpec

pub struct FigurePlacement {
  pos : Position
  layer : Int
  scalars : ScalarState
}
pub impl Eq for FigurePlacement
pub impl Show for FigurePlacement
pub impl ToJson for FigurePlacement
pub impl @json.FromJson for FigurePlacement

type GalleryTileView
pub impl Eq for GalleryTileView
pub impl Show for GalleryTileView
pub impl ToJson for GalleryTileView
pub impl @json.FromJson for GalleryTileView

type GameRunner[T]
pub fn[T] GameRunner::apply_runtime_event(Self[T], RuntimeEvent) -> Unit
pub fn[T] GameRunner::apply_settings(Self[T], @storage.GameSettings) -> Unit
pub async fn[T] GameRunner::clear_presentation(Self[T]) -> Unit
pub fn[T] GameRunner::clear_ui(Self[T]) -> Unit
pub fn[T] GameRunner::complete_typewriter(Self[T]) -> Unit
pub fn[T] GameRunner::dialog_history(Self[T]) -> Array[DialogLogEntry]
pub fn[T] GameRunner::director(Self[T]) -> Director[T]
pub fn[T] GameRunner::flow_trace(Self[T]) -> Array[ScriptFlowTrace]
pub fn[T] GameRunner::is_log_visible(Self[T]) -> Bool
pub fn[T] GameRunner::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] GameRunner::log_build_state(Self[T]) -> LogBuildState
pub fn[T] GameRunner::new(Director[T], UiDom) -> Self[T]
pub fn[T] GameRunner::new_with_hooks(Director[T], UiDom, async (Director[T]) -> Unit noraise, (RuntimeEvent) -> Unit) -> Self[T]
pub fn[T] GameRunner::new_with_render_sync(Director[T], UiDom, async (Director[T]) -> Unit noraise) -> Self[T]
pub fn[T] GameRunner::reconstruct_dialog_history(Self[T], Script[T], @core.GameState[T], max_steps? : Int) -> Unit raise LogReconstructionError
pub fn[T] GameRunner::set_log_build_state(Self[T], LogBuildState) -> Unit
pub fn[T] GameRunner::set_log_visible(Self[T], Bool) -> Unit
pub fn[T] GameRunner::simulate_click(Self[T]) -> Unit
pub fn[T] GameRunner::start_reconstruct_dialog_history(Self[T], Script[T], @core.GameState[T], max_steps? : Int) -> Unit
pub async fn[T] GameRunner::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] GameRunner::submit_choice(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] GameRunner::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub async fn[T] GameRunner::sync_ui(Self[T]) -> Unit
pub fn[T] GameRunner::take_game_action(Self[T]) -> String?
pub fn[T] GameRunner::take_pending_action(Self[T]) -> String?
pub async fn[T] GameRunner::tick(Self[T], elapsed_ms? : Int) -> Bool
pub fn[T] GameRunner::toggle_auto_mode(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_log_visible(Self[T]) -> Unit
pub fn[T] GameRunner::toggle_skip_mode(Self[T]) -> Unit

pub enum Instruction[T] {
  Label(String)
  Jump(String)
  JumpIf(String, (@core.GameState[T]) -> Bool)
  Wait(Int)
  WaitForClick(Bool)
  WaitCustomEvent(String, (@core.GameState[T], String) -> Bool)
  WaitCustomEventJump(String, (@core.GameState[T], String) -> Label)
  Say(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?, proceed_on_done~ : Bool)
  Intro(String)
  ShowTextBox
  HideTextBox
  ShowAvatar(String)
  HideAvatar
  PlayVideo(String, Bool)
  Choice(Array[ChoiceOption])
  InputText(String, String)
  RunCode((@core.GameState[T]) -> Unit)
  ShowBackground(String)
  ShowBackgroundState(BackgroundState)
  ShowFigure(String, FigurePlacement)
  HideFigure(String)
  ShowDomFigure(String, FigurePlacement, Bool)
  HideDomFigure(String)
  SetDomFigureInteractive(String, Bool)
  PlayMusic(String, Bool)
  StopMusic
  PlaySfx(String, Bool)
  UnlockCg(String)
  AnimatePixi(String, AnimationSpec)
  AnimateDom(String, AnimationSpec)
  ApplyEffect(String, EffectSpec)
  PlayLive2dMotion(String, String, Int?)
  SetLive2dExpression(String, String?)
}

type Label

pub enum LogBuildState {
  NotBuilt
  Building
  Ready
}
pub impl Eq for LogBuildState
pub impl Show for LogBuildState

type PixiApplication
pub async fn PixiApplication::init_with_canvas(Self, @js.Value, Int, Int, antialias? : Bool, background_alpha? : Double, resolution? : Double, auto_density? : Bool) -> Unit

type PixiBlurFilter

type PixiCanvas

type PixiColorMatrixFilter

type PixiContainer

pub enum PixiEffectTarget {
  Sprite(PixiSprite)
  Live2d(PixiLive2dModel)
}

type PixiFilter

type PixiLive2dModel
pub fn PixiLive2dModel::destroy(Self) -> Unit
pub async fn PixiLive2dModel::expression(Self, id? : String) -> Bool
pub fn PixiLive2dModel::focus(Self, Double, Double, instant? : Bool) -> Unit
pub fn PixiLive2dModel::height(Self) -> Double
pub async fn PixiLive2dModel::motion(Self, String, index? : Int) -> Bool noraise
pub fn PixiLive2dModel::set_alpha(Self, Double) -> Unit
pub fn PixiLive2dModel::set_anchor(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_expression(Self, @js.Optional[String]) -> Unit
pub fn PixiLive2dModel::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiLive2dModel::set_interactive(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_position(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_rotation(Self, Double) -> Unit
pub fn PixiLive2dModel::set_scale(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_size(Self, Double, Double) -> Unit
pub fn PixiLive2dModel::set_visible(Self, Bool) -> Unit
pub fn PixiLive2dModel::set_z_index(Self, Int) -> Unit
pub fn PixiLive2dModel::width(Self) -> Double

pub struct PixiPresenterConfig {
  antialias : Bool
  background_alpha : Double
  resolution : Double
  auto_density : Bool
  position_entry_offset_ratio : Double
  scale_entry_from : Double
}
pub impl Eq for PixiPresenterConfig
pub impl Show for PixiPresenterConfig

type PixiSprite
pub fn PixiSprite::set_alpha(Self, Double) -> Unit
pub fn PixiSprite::set_filters(Self, Array[@js.Value]) -> Unit
pub fn PixiSprite::set_position(Self, Double, Double) -> Unit
pub fn PixiSprite::set_rotation(Self, Double) -> Unit
pub fn PixiSprite::set_scale(Self, Double, Double) -> Unit
pub fn PixiSprite::set_tint(Self, Int) -> Unit

type PixiTexture

pub(all) enum Position {
  Left
  Center
  Right
  Custom(Double, Double)
}
pub impl Eq for Position
pub impl Show for Position
pub impl ToJson for Position
pub impl @json.FromJson for Position

pub struct RenderState {
  mut background : BackgroundState?
  figures : Map[String, FigurePlacement]
  dom_figures : Map[String, DomFigureState]
  mut music : (String, Bool)?
  mut last_sfx : String?
  mut last_sfx_interrupted : Bool
  pixi_animations : Array[(String, AnimationSpec)]
  dom_animations : Array[(String, AnimationSpec)]
  effects : Map[String, Array[EffectSpec]]
  live2d_motions : Array[(String, String, Int?)]
  live2d_expressions : Array[(String, String?)]
  render_epoch : String
}
pub impl ToJson for RenderState
pub impl @json.FromJson for RenderState

pub struct Runtime[T] {
  script : Script[T]
  state : @core.GameState[T]
  mut ip : Int
  mut pending_choices : Array[ChoiceOption]
  mut pending_choice_ip : Int?
  mut pending_text_input : (String, String)?
  mut wait_ms : Int
  mut wait_for_click : Bool
  mut wait_for_click_can_skip : Bool
  mut wait_custom_name : String?
  mut wait_video : Bool
  mut last_say_proceed_on_done : Bool
  mut ended : Bool
  flow_trace : Array[ScriptFlowTrace]
}
pub fn[T] Runtime::can_auto_skip_wait_click(Self[T]) -> Bool
pub fn[T] Runtime::can_skip_wait(Self[T]) -> Bool
pub fn[T] Runtime::choose(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::complete_video_wait(Self[T], Bool) -> RuntimeEvent
pub fn[T] Runtime::flow_trace(Self[T]) -> Array[ScriptFlowTrace]
pub fn[T] Runtime::force_custom_jump(Self[T], String, String) -> Unit raise ScriptRuntimeError
pub fn[T : @json.FromJson] Runtime::from_json_string(Script[T], String) -> Self[T] raise
pub fn[T] Runtime::ip(Self[T]) -> Int
pub fn[T] Runtime::is_waiting(Self[T]) -> Bool
pub fn[T] Runtime::is_waiting_video(Self[T]) -> Bool
pub fn[T] Runtime::jump_to_label(Self[T], String) -> Unit raise ScriptRuntimeError
pub fn[T] Runtime::last_say_proceed_on_done(Self[T]) -> Bool
pub fn[T] Runtime::new(Script[T], @core.GameState[T]) -> Self[T]
pub fn[T] Runtime::save(Self[T]) -> RuntimeSave[T]
pub fn[T : ToJson] Runtime::save_json(Self[T]) -> String
pub fn[T] Runtime::skip_wait(Self[T]) -> Unit
pub fn[T] Runtime::step(Self[T], elapsed_ms? : Int) -> RuntimeEvent raise ScriptRuntimeError
pub fn[T] Runtime::submit_custom_event(Self[T], String, String) -> RuntimeEvent
pub fn[T] Runtime::submit_text_input(Self[T], String) -> RuntimeEvent raise ScriptRuntimeError

pub enum RuntimeEvent {
  Noop
  Said(speaker~ : String, text~ : String, typewriter~ : Bool, append~ : Bool, voice~ : String?)
  IntroShown(String)
  TextBoxShown
  TextBoxHidden
  AvatarShown(String)
  AvatarHidden
  VideoStarted(String, Bool)
  VideoEnded(Bool)
  ChoicePrompt(Array[ChoiceOption])
  TextInputPrompt(String, String)
  BackgroundShown(String)
  BackgroundShownState(BackgroundState)
  FigureShown(String, FigurePlacement)
  FigureHidden(String)
  DomFigureShown(String, FigurePlacement, Bool)
  DomFigureHidden(String)
  DomFigureInteractiveSet(String, Bool)
  MusicPlayed(String, Bool)
  MusicStopped
  SfxPlayed(String, Bool)
  SfxStopped
  CgUnlocked(String)
  AnimatedPixi(String, AnimationSpec)
  AnimatedDom(String, AnimationSpec)
  EffectApplied(String, EffectSpec)
  Live2dMotionPlayed(String, String, Int?)
  Live2dExpressionSet(String, String?)
  WaitStarted(Int)
  WaitForClickStarted
  WaitCustomEventStarted(String)
  Custom(String, String)
  ScriptEnded
}
pub impl Eq for RuntimeEvent
pub impl Show for RuntimeEvent

pub struct RuntimeSave[T] {
  state : @core.GameState[T]
  ip : Int
  pending_choices : Array[ChoiceOption]
  pending_choice_ip : Int?
  pending_text_input : (String, String)?
  wait_ms : Int
  wait_for_click : Bool
  wait_for_click_can_skip : Bool
  wait_custom_name : String?
  wait_video : Bool
  last_say_proceed_on_done : Bool
  ended : Bool
  flow_trace : Array[ScriptFlowTrace]
}
pub impl[T : ToJson] ToJson for RuntimeSave[T]
pub impl[T : @json.FromJson] @json.FromJson for RuntimeSave[T]

pub struct SaveSlotPayload {
  version : Int
  director_json : String
}
pub impl ToJson for SaveSlotPayload
pub impl @json.FromJson for SaveSlotPayload

pub(all) struct ScalarState {
  opacity : Double
  scale : Double
  rotation : Double
  blur : Double
  brightness : Double
  contrast : Double
  saturation : Double
  gamma : Double
  color_r : Double
  color_g : Double
  color_b : Double
}
pub impl Default for ScalarState
pub impl Eq for ScalarState
pub impl Show for ScalarState
pub impl ToJson for ScalarState
pub impl @json.FromJson for ScalarState

pub struct Script[T] {
  instructions : Array[Instruction[T]]
  labels : Map[String, Int]
}

type ScriptBuilder[T]
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate(Self[T], A, AnimationSpec) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_blur(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_brightness(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_blue(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_green(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_color_red(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_contrast(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_gamma(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_opacity(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_position(Self[T], A, Int, from? : Position, Position, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_rotation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_saturation(Self[T], A, Int, from? : Double, Double, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T, A : @assets.AnimationTarget] ScriptBuilder::animate_scale(Self[T], A, Int, from? : Double, Double, anchor? : (Double, Double), easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::apply(Self[T], (Self[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::branch(Self[T], Label, Label, (@core.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::build(Self[T]) -> Script[T] raise ScriptBuildError
pub fn[T] ScriptBuilder::choice(Self[T], Array[ChoiceOption]) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect(Self[T], A, EffectSpec) -> Unit
pub fn[T, A : @assets.PixiTarget] ScriptBuilder::effect_with(Self[T], A, Effect, Array[(String, Double)], phase? : EffectPhase, duration_ms? : Int, easing? : Easing, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::hide_avatar(Self[T]) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::hide_figure(Self[T], F) -> Unit
pub fn[T] ScriptBuilder::hide_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::input_text(Self[T], String, String) -> Unit
pub fn[T] ScriptBuilder::intro(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::jump(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::jump_if(Self[T], Label, (@core.GameState[T]) -> Bool) -> Unit
pub fn[T] ScriptBuilder::label(Self[T], Label) -> Unit
pub fn[T] ScriptBuilder::load_text(Self[T], String) -> Unit
pub fn[T] ScriptBuilder::menu(Self[T], String, String, Array[ChoiceOption]) -> Unit
pub fn[T] ScriptBuilder::narrate(Self[T], String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::new() -> Self[T]
pub fn[T] ScriptBuilder::play_live2d_motion(Self[T], @assets.Live2dFigure, String, index? : Int) -> Unit
pub fn[T] ScriptBuilder::play_music(Self[T], @assets.Music, Bool) -> Unit
pub fn[T] ScriptBuilder::play_sfx(Self[T], @assets.Sfx, blocking? : Bool) -> Unit
pub fn[T] ScriptBuilder::play_video(Self[T], String, can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::run_code(Self[T], (@core.GameState[T]) -> Unit) -> Unit
pub fn[T] ScriptBuilder::say(Self[T], String, String, typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::say_many(Self[T], String, Array[String], typewriter? : Bool, append? : Bool, voice? : String, proceed_on_done? : Bool) -> Unit
pub fn[T] ScriptBuilder::scene(Self[T], @assets.Background, scalars? : ScalarState) -> Unit
pub fn[T] ScriptBuilder::set_figure_interactive(Self[T], @assets.DomFigure, Bool) -> Unit
pub fn[T] ScriptBuilder::set_live2d_expression(Self[T], @assets.Live2dFigure, id? : String) -> Unit
pub fn[T] ScriptBuilder::show_avatar(Self[T], String) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure(Self[T], F, FigurePlacement, interactive? : Bool) -> Unit
pub fn[T, F : @assets.Figure] ScriptBuilder::show_figure_at(Self[T], F, Position, layer? : Int, scalars? : ScalarState, interactive? : Bool) -> Unit
pub fn[T] ScriptBuilder::show_text_box(Self[T]) -> Unit
pub fn[T] ScriptBuilder::stop_music(Self[T]) -> Unit
pub fn[T] ScriptBuilder::unlock_cg(Self[T], @gallery.GalleryImage) -> Unit
pub fn[T] ScriptBuilder::wait(Self[T], Int) -> Unit
pub fn[T] ScriptBuilder::wait_click(Self[T], can_skip? : Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event(Self[T], String, (@core.GameState[T], String) -> Bool) -> Unit
pub fn[T] ScriptBuilder::wait_custom_event_jump(Self[T], String, (@core.GameState[T], String) -> Label) -> Unit

pub enum ScriptFlowTrace {
  ChoiceResolved(ip~ : Int, choice_id~ : String)
  JumpIfResolved(ip~ : Int, target~ : String, taken~ : Bool)
  CustomJumpResolved(ip~ : Int, name~ : String, target~ : String)
}
pub impl Eq for ScriptFlowTrace
pub impl Show for ScriptFlowTrace
pub impl ToJson for ScriptFlowTrace
pub impl @json.FromJson for ScriptFlowTrace

pub enum SettingsContext {
  FromStartMenu
  FromMidgame
}
pub impl Eq for SettingsContext
pub impl Show for SettingsContext

type UiChoiceView
pub impl Eq for UiChoiceView
pub impl Show for UiChoiceView

type UiDom
pub fn UiDom::advance_auto_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_dom_animation_timer(Self, Int) -> Unit
pub fn UiDom::advance_skip_mode_timer(Self, elapsed_ms~ : Int) -> Unit
pub fn UiDom::advance_typewriter(Self, elapsed_ms~ : Int) -> Bool
pub fn UiDom::clear_game_ui(Self) -> Unit
pub fn UiDom::complete_typewriter(Self) -> Unit
pub fn UiDom::has_active_dom_animations(Self) -> Bool
pub fn UiDom::is_log_building(Self) -> Bool
pub fn UiDom::is_log_visible(Self) -> Bool
pub fn UiDom::is_skip_active(Self) -> Bool
pub fn UiDom::is_typewriter_done(Self) -> Bool
pub fn UiDom::mark_all_dirty(Self) -> Unit
pub fn UiDom::mark_auto_advanced(Self) -> Unit
pub fn UiDom::mark_dirty_action_buttons(Self) -> Unit
pub fn UiDom::mark_dirty_choices(Self) -> Unit
pub fn UiDom::mark_dirty_text(Self) -> Unit
pub fn UiDom::mark_dirty_text_input(Self) -> Unit
pub fn UiDom::mark_skip_advanced(Self) -> Unit
pub fn UiDom::set_auto_mode(Self, Bool) -> Unit
pub fn UiDom::set_log_building(Self, Bool) -> Unit
pub fn UiDom::set_log_visible(Self, Bool) -> Unit
pub fn UiDom::set_media_volume(Self, Double) -> Unit
pub fn UiDom::set_skip_hold(Self, Bool) -> Unit
pub fn UiDom::set_skip_mode(Self, Bool) -> Unit
pub fn UiDom::set_text_speed(Self, Int) -> Unit
pub fn UiDom::should_auto_advance(Self) -> Bool
pub fn UiDom::should_auto_skip_wait_click(Self) -> Bool
pub fn UiDom::should_skip_advance(Self) -> Bool
pub fn UiDom::simulate_click(Self) -> Unit
pub fn UiDom::simulate_intro_done(Self) -> Unit
pub fn UiDom::start_typewriter(Self, String) -> Unit
pub fn UiDom::text_speed_ms_per_char(Self) -> Int
pub fn UiDom::toggle_auto_mode(Self) -> Unit
pub fn UiDom::toggle_log_visible(Self) -> Unit
pub fn UiDom::toggle_skip_mode(Self) -> Unit
pub fn UiDom::typewriter_visible_text(Self) -> StringView

type UiDomFigureView
pub impl Eq for UiDomFigureView
pub impl Show for UiDomFigureView
pub impl ToJson for UiDomFigureView
pub impl @json.FromJson for UiDomFigureView

type UiTextInputView
pub impl Eq for UiTextInputView
pub impl Show for UiTextInputView

type UiVideoView
pub impl Eq for UiVideoView
pub impl Show for UiVideoView

type UiViewModel
pub impl Eq for UiViewModel
pub impl Show for UiViewModel

// Type aliases
pub type EffectParam = (String, Double)

pub type EventHook = (RuntimeEvent) -> Unit

pub type PayloadJumpSelector[T] = (@core.GameState[T], String) -> Label

pub type PayloadPredicate[T] = (@core.GameState[T], String) -> Bool

pub type PixiEffectApply = (PixiSprite, Array[(String, Double)], Int) -> Bool

pub type PixiSharedEffectApply = (PixiEffectTarget, Array[(String, Double)], Int) -> Bool

pub type RenderSyncHook[T] = async (Director[T]) -> Unit noraise

pub type ScriptFactory[T] = async () -> Script[T]

pub type ScriptHook[T] = (@core.GameState[T]) -> Unit

pub type ScriptPredicate[T] = (@core.GameState[T]) -> Bool

// Traits

